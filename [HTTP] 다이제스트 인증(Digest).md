# 다이제스트 인증의 개선점
* 다이제스트 인증은 기본 인증의 가장 심각한 결함을 수정한 또 다른 HTTP 인증 프로토콜이다. 
</br>

* 현재 다이제스트 인증은 그다지 사용되고 있지 않다.
</br>

* **다이제스트 인증의 특징**
  * 비밀번호를 절대로 네트워크를 통해 평문으로 전송하지 않는다.
  * 인증 체결을 가로채서 재현하려는 악의적인 사람들을 차단한다.
  * 구현하기에 따라서, 메시지 내용 위조를 막는 것도 가능하다.
  * 그 외 몇몇 잘 알려진 형태의 공격을 막는다. 
</br>

* 가장 안전한 프로토콜은 아니지만 [기본 인증](https://github.com/AgustaRC/dev_log/blob/master/%5BHTTP%5D%20%EA%B8%B0%EB%B3%B8%20%EC%9D%B8%EC%A6%9D(Basic).md)보다 훨씬 강력하다.
</br>

* **비밀번호를 안전하게 지키기 위해 요약 사용하기**
  * 다이제스트 인증의 좌우명은 **“절대로 비밀번호를 네트워크를 통해 보내지 않는다"**
  * 비밀번호를 보내는 대신 클라이언트는 비밀번호를 비가역적으로 뒤섞은 ```‘지문(fingerprint)’``` 혹은 ```‘요약(digest)’```을 보낸다. 
  * 클라이언트와 서버는 둘 다 비밀번호를 알고 있으므로, 서버는 클라이언트가 보낸 요약이 비밀번호에 알맞게 대응하는지 검사할 수 있다. 
  * 단방향 해시 함수로 비밀번호를 요약하고 서버에서도 해당 사용자의 비밀번호를 단방향 해시 함수로 요약한 결과가 일치하는지 검사한다.
</br>

* **MD5**
  * 128비트 암호화 해시 함수
  * 임의의 바이트 배열을 원래 길이와 상관없이 128비트 요약으로 변환
  * 원본 무결성 체크 등에 주로 사용
  * 보안용으로는 사용되지 않음 
</br>

* **재전송 방지를 위한 난스(nonce) 사용**
  * 요약을 사용한다고 해도 불투명 비밀번호 자체로는 우리를 위험에서 지켜주지 못한다.
  * 공격자가 비밀번호를 모른다고 해도 요약을 가로채서 서버로 몇 번이고 재전송할 수 있기 때문이다. 
  * 이런 재전송 공격을 방지하기 위해서 서버는 클라이언트에게 난스라고 불리는 특별한, 그리고 자주 바뀌는(대략 1밀리 초마다, 혹은 인증할 때마다) 증표를 건네준다. 
  * 난스를 비밀번호에 섞으면 난스가 바뀔 때마다 요약도 바뀌게 만들어 준다. 
  * 저장된 비밀번호 요약은 특정 난스 값에 대해서만 유효하기 때문에, 비밀번호 없이 공격자가 올바른 요약을 계산하는 것은 가능하지 않다. 
  * 난스는 ```WWW-Authenticate``` 인증 요구에 담겨서 서버에서 클라이언트로 넘겨진다. 
</br>

* **다이제스트 인증 핸드 셰이크**
  * 기본 인증에서 사용하는 것과 비슷한 헤더를 사용하는, 강화된 버전의 인증이다.
  * 기존 헤더에 몇몇 새 옵션이 추가되었고, 선택적인 헤더는 ```Authorization-Info```가 새로 추가되었다. 
  * 1단계 : 서버는 난스 값을 계산한다. 
  * 2단계 : 서버는 난스를 ```WWW-Authenticate``` 인증 요구 메시지에 담아, 서버가 지원하는 알고리즘 목록과 함께 클라이언트에 전송한다. 
  * 3단계 : 클라이언트는 알고리즘을 선택하고 비밀번호와 그 외 데이터에 대한 요약을 계산한다.
  * 4단계 : 클라이언트는 ```Authorization``` 메시지에 요약을 담아 서버에게 돌려준다. 
  * 5단계 : 서버는 요약, 선택한 알고리즘, 그 외 보조 데이터들을 받고, 클라이언트가 했던 그대로 요약을 계산한다. 
  * 서버는 클라이언트가 미리 다음번 요약을 올바르게 생성할 수 있도록 다음번 난스를 미리 계산해 클라이언트에게 넘겨줄 수도 있다. 
</br>

# 요약(Digest) 계산
* **요약 알고리즘 입력 데이터**
  * 단방향 해시 함수 ```H(d)```와 요약 함수 ```KD(s, d)```. 여기서 ```s는 비밀(secret)```을, ```d는 데이터(data)```를 의미한다.
  * 비밀번호 등 보안 정보를 담고 있는 데이터 덩어리. ```A1```이라 칭한다.
  * 요청 메시지의 비밀이 아닌 속성을 담고 있는 데이터 덩어리. ```A2```라 칭한다. 
  * A1, A2 두 조각의 데이터는 요약을 생성하기 위해 H와 KD에 의해 처리된다. 
</br>

* **H(d)와 KD(s, d) 알고리즘**
  * 다이제스트 인증은 여러 가지 요약 알고리즘을 선택할 수 있도록 지원한다. 
  * 만약 알고리즘이 정해지지 않았다면 MD5가 기본값이다.
  * ```H(<데이터>) = MD5(<데이터>)```
  * ```KD(<비밀>, <데이터>) = H(연결(<비밀>:<데이터>))```
</br>

* **보안 관련 데이터(A1)**
  * A1으로 불리는 데이터 덩어리는 사용자 이름, 비밀번호, 보호 영역, 난스와 같은 비밀 보호 정보로 이루어져 있다.
  * 메시지 자체가 아닌 비밀 정보와만 관련되어 있다.
  * MD5 : 모든 요청마다 단방향 해시를 실행한다. A1은 사용자 이름, 영역, 비밀번호를 콜론으로 연결한 것이다. 
  * MD5-sess : 사용자 이름, 영역, 비밀번호에 대한 해시를 계산한 결과 뒤에 현재 난스와 클라이언트 난스(c난스)를 붙인 것이 A1이 된다. 
  CPU를 많이 사용하는 해시 계산은 처음 ```WWW-Authenticate``` 핸드 셰이크를 할 때 단 한 번만 수행한다. 
</br>

* **메시지 관련 데이터(A2)**
  * A2로 불리는 데이터 덩어리는 URL, 요청 메서드, 메시지 엔터티 본문과 같은 메시지 자체의 정보를 나타낸다. 
  * A2는 메서드, 리소스, 메시지의 위조를 방지하기 위해 사용된다. 
  * RFC 2617은 선택된 ```보호 수준(quality of protection, qop)```에 따른 A2의 두 가지 사용법을 정의하고 있다.
    * HTTP 요청 메서드와 URL만 포함하는 것, ```qop=“auth”```일 때 사용
    * 메시지 무결성 검사를 제공하기 위해 메시지 엔터티 본문을 추가하는 것, ```qop=“auth-init”```일 때 사용
</br>

* **요약 알고리즘 전반**
  * RFC 2617은 주어진 H, KD, A1, A2로 요약을 계산하는 두 가지 방법을 정의한다. 
    * 예전 명세인 RFC 2069와 호환을 염두에 둔 것으로, qop 옵션이 빠졌을 때 사용된다. 비밀 정보와 난스가 붙은 메시지 데이터의 해시를 이용해 요약을 계산한다.
    * 현대적이면서 보다 선호되는 접근법으로 난스 횟수 집계 및 대칭 인증의 지원을 포함한다. 이 접근법은 ```qop```가 ```‘auth’```일 때와 ```‘auth-init’```일 때 모두 사용된다. 이것은 난스 횟수, qop, c난스 데이터를 요약에 추가한다. 
</br>

* **다이제스트 인증 세션**
  * 어떤 보호 공간을 위한 ```WWW-Authenticate``` 인증 요구에 대한 클라이언트 응답은, 그 보호 공간에 대한 인증 세션을 시작하게 한다. 
  * 인증 세션은 클라이언트가 보호 공간의 다른 서버로부터 또 다른 ```WWW-Authenticate``` 인증 요구를 받을 때까지 지속된다. 
  * 클라이언트는 사용자 이름, 비밀번호, 난스, 난스 횟수, 그리고 보호 공간 내 미래의 요청에 들어갈 ```Authorization``` 헤더를 만들기 위해 사용될 인증 세션과 연관된 알아보기 힘든 값들을 기억해야 한다.
  * 난스가 만료되면, 서버는 포함된 난스 값이 낡은 것일 수 있음을 감수하고 오래된 ```Authorization``` 헤더 정보를 받아들이는 것을 택할 수 있다. 
  * 아니면, 서버는 클라이언트가 다시 요청을 보내도록 새 난스 값과 함께 401 응답을 반환할 수도 있다. 
  * 이때 이 응답에 ```“stale=true”```로 정의함으로써 서버는 클라이언트에게 사용자 이름과 비밀번호를 새로 입력하도록 창을 띄울 필요 없이 새 난스 값으로 요청을 다시 보내라고 말해줄 수 있다. 
</br>

* **사전(preemptive) 인가**
  * 일반적인 인증에서는, 각 요청은 트랜잭션이 완료되기 전에 요청/인증 요구 사이클을 필요로 한다. 
  * 만약 클라이언트가 다음 난스가 무엇이 될지 미리 알고 있어서, 서버가 물어보기 전에 올바른 ```Authorization``` 헤더를 생성할 수 있다면, 이 요청/인증 요구 사이클은 생략될 수 있다. 
  * 안전한 기능을 유지하면서 사전 인가를 할 수 있는 세 가지 방법
    * 서버가 다음 난스를 ```Authentication-Info``` 성공 헤더에 담아서 미리 보낸다. 
    * 서버가 짧은 시간 동안 같은 난스를 재사용하는 것을 허용한다.
    * 클라이언트와 서버가 동기화되어 있고 예측 가능한 난스 생성 알고리즘을 사용한다. 
</br>

* **다음 난스 미리 생성하기**
  * 서버는 인증이 성공했을 때 200 OK 응답과 함께 ```Authentication-Info : nextnonce=“<난스 값>”``` 이 헤더를 미리 보낸다. 
  * 요청/인증 요구 사이클에서 벗어날 수 있어서 트랜잭션 속도 향상
  * 같은 서버에 다중 요청을 ```파이프라이닝(pipelining)```하는 능력은 실질적으로 쓸모가 없어진다. 
  * 다음 요청을 보내기 전에 다음 난스 값을 받아야 하기 때문
  * 파이프라이닝은 회전 지연(latency)회피를 위한 기반 기술이기 때문에 성능상 불이익은 더 커진다. 
</br>

* **제한된 난스 재사용**
  * 예를 들어 서버는 한 난스를 다섯 번 혹은 10초간 재사용하도록 허락할 수 있다. 
  * 난스를 재사용하면 공격자의 재전송 공격이 성공하기 쉬워지므로 보안성이 감소된다.
  * 취약점과 성능 간의 트레이드오프
  * 추가적으로, 카운터 증가나 IP 주소 검사와 같이 재전송 공격을 더 어렵게 만들 수 는 다른 기능들을 채택할 수도 있지만 이러한 기법은 공격을 불편하게 만들기만 할 뿐 취약점을 제거할 순 없다. 
</br>

* **동기화된 난스 생성**
  * 제3자가 쉽게 예측할 수 없는 공유된 비밀키(안전 ID 카드처럼)에 기반하면서 클라이언트와 서버가 순차적으로 같은 난스를 생성할 수 있도록 시간적으로 동기화된 난스 생성 알고리즘
</br>

* **난스 선택**
  * 난스의 내용은 불투명하고 구현 의존적이다.
  * RFC 2617이 제안한 가상의 난스 공식 : ```BASE64(타임스탬프 H(타임스탬프 “:” ETag “:” 개인키))```
  * 타임스탬프는 서버에서 생성된 시간 혹은 아무것이나 반복 불가능한 값이면 된다.
  * ETag는 요청된 엔터티에 대한 ETag 헤더값
  * 개인키는 서버만이 알고 있는 값
</br>

# 보안에 대한 고려사항
* **헤더 부당 변경**
  * 헤더 부당 변경에 대해 항상 안전한 시스템을 제공하기 위해서, 양 종단 암호화나 헤더에 대한 디지털 서명이 필요할 것이다.
</br>

* **재전송 공격**
  * 누군가 어떤 트랜잭션에서 엿들은 인증 자격을 다른 트랜잭션을 위해 사용하는 것
  * 재전송 공격을 완전히 피할 수 있는 한 방법은 매 트랜잭션마다 유일한 난스 값을 사용하는 것
  * 발급된 난스 값은 그때의 트랜잭션과 주어진 타임아웃 값의 기간 동안만 유효하다. 이 계산이 서버에 부하를 가중시킬 수도 있지만 사소한 수준일 것이다.
</br>

* **다중 인증 메커니즘**
  * 서버가 다중 인증 제도를 지원할 때(기본과 요약을 모두 지원한다거나), ```WWW-Authenticate``` 헤더를 통해 선택지를 제공할 것이다. 
  * 클라이언트에게 가장 강력한 인증 메커니즘을 선택해야 할 의무가 있는 것은 아니기 때문에, 결국 인증의 강도는 선택지 중 가장 약한 것과 같다고 보아야 한다. 
  * 가장 강력한 인증 제도만을 유지하는 프락시 서버를 사용하는 방법이 있음. (예: 사내 네트워크)
</br>

* **사전(dictionary) 공격**
  * 비밀번호 추측 공격
  * 공격자는 트랜잭션을 엿들을 수 있고 난스/응답 쌍에 대해 흔히 구할 수 있는 비밀번호 추측 프로그램을 사용할 수 있다. 
  * 만약 사용자가 상대적으로 단순한 비밀번호를 사용하고 서버도 단순한 난스를 사용하고 있다면 맞는 것을 찾아낼 확률이 꽤 있다. 
  * 해결하기 위한 좋은 방법은, 크래킹 하기 어렵도록 상대적으로 복잡한 비밀번호를 사용하는 것과 괜찮은 비밀번호 만료 정책 외에는 실질적으로 없다. 
   
