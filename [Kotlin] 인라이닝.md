# 인라이닝
  * **인라이닝이 작동하는 방식**
    * 어떤 함수를 ```inline```으로 선언하면 그 함수의 본문이 인라이닝된다. 
    * 함수를 호출하는 바이트코드 대신에 함수 본문을 번역한 바이트 코드로 컴파일하는 것.
    * 간단한 ```inline``` 함수 예제
      ```kotlin
      inline fun <T> synchronized(lock: Lock, action: () -> T): T {
        lock.lock()
        try {
          return action()
        } finally {
          lock.unlock()
        }
      }

      val l = Lock()
      synchronized(l) {
        ...
      }
      ```
    * 위 예제 코드에서 함수뿐만 아니라 파라미터로 전달된 람다의 본문도 함께 인라이닝된다.
    * 람다의 본문에 의해 만들어지는 바이트코드는 그 람다를 호출하는 코드(```synchronized```) 정의의 일부분으로 간주되기 때문에 코틀린 컴파일러는 그 람다를 함수 인터페이스를 구현하는 무명 클래스로 감싸지 않는다.
    * 인라인 함수를 호출하면서 람다를 넘기는 대신에 함수 타입의 변수를 넘길 수도 있다. 
      ```kotlin
      class LockOwner(val lock: Lock) {
        fun runUnderLock(body: () -> Unit) {
          synchronized(lock, body) // 람다 대신에 함수 타입인 변수를 인자로 넘긴다.
        }
      }
      ```
    * 위의 경우 인라인 함수를 호출하는 코드 위치에서는 변수에 저장된 람다의 코드를 알 수 없다. 
    * 따라서 람다 본문은 인라이닝되지 않고 ```synchronized``` 함수의 본문만 인라이닝된다.
    * 따라서 람다는 다른 일반적인 경우와 마찬가지로 호출된다.
    * ```runUnderLock```을 컴파일한 바이트코드는 다음과 같다.
      ```kotlin
      class LockOwner(val lock: Lock) {
        fun __runUnderLock__(body: () -> Unit) {
          lock.lock()
          try {
            body() // synchronized를 호출하는 부분에서 람다를 알 수 없으므로 본문(body())은 인라이닝되지 않는다.
          } finally {
            lock.unlock()
          }
        }
      }
      ```
    * 한 인라인 함수를 두 곳에서 각각 다른 람다를 사용해 호출한다면 그 두 호출은 각각 따로 인라이닝된다. 
    * 인라인 함수의 본문 코드가 호출 지점에 복사되고 각 람다의 본문이 인라인 함수의 본문 코드에서 람다를 사용하는 위치에 복사된다.
    <br>

  * **인라인 함수의 한계**
    * 인라이닝을 하는 방식으로 인해 람다를 사용하는 모든 함수를 인라이닝할 수는 없다.
    * 함수 본문에서 파라미터로 받은 람다를 호출한다면 그 호출을 쉽게 람다 본문으로 바꿀 수 있다.
    * 하지만 파라미터로 받은 람다를 다른 변수에 저장하고 나중에 그 변수를 사용한다면 람다를 표현하는 객체가 어딘가는 존재해야 하기 때문에 람다를 인라이닝할 수 없다.
    * 일반적으로 인라인 함수의 본문에서 람다 식을 바로 호출하거나 람다 식을 인자로 전달받아 바로 호출하는 경우에는 그 람다를 인라이닝할 수 있다. 
      ```kotlin
      fun <T, R> Sequence<T>.map(transform: (T) -> R): Sequence<R> {
        return TransformingSequence(this, transform)
      }
      ```
    * 위의 예제 코드에서 ```map``` 함수는 ```transform``` 파라미터로 전달받은 함수 값을 호출하지 않는 대신, ```TransformingSequence```라는 클래스의 생성자에게 그 함수 값을 넘긴다.
    * ```TransformingSequence``` 생성자는 전달받은 람다를 프로퍼티로 저장한다. 
    * 이런 기능을 지원하려면 ```map```에 전달되는 ```transform``` 인자를 일반적인(인라이닝하지 않는) 함수 표현으로 만들 수밖에 없다.
    * 즉, 여기서는 ```transform```을 함수 인터페이스를 구현하는 무명 클래스 인스턴스로 만들어야만 한다.
    <br>
    
  * **인라이닝 금지**
    * 둘 이상의 람다를 인자로 받는 함수에서 일부 람다만 인라이닝하고 싶을 때도 있다.
    * 예를 들어 어떤 람다에 너무 많은 코드가 들어가거나 어떤 람다에 인라이닝을 하면 안 되는 코드가 들어갈 가능성이 있다면 그런 람다를 인라이닝하면 안 된다.
    * 이런 식으로 인라이닝하면 안 되는 람다를 파라미터로 받는다면 ```noinline``` 변경자를 파라미터 이름 앞에 붙여서 인라이닝을 금지할 수 있다.
      ```kotlin
      inline fun foo(inlined: () -> Unit, noinline notInlined: () -> Unit) {
        ...
      }
      ```
    * 자바에서 코틀린에 정의된 인라인 함수를 호출할 경우 컴파일러는 인라인 함수를 인라이닝 하지 않고 일반 함수 호출로 컴파일한다. 
    <br>
    
  * **컬렉션 연산 인라이닝**
    * 코틀린 표준 라이브러리의 컬렉션 함수는 대부분 람다를 인자로 받는다. 
      ```kotlin
      people.filter { it.age > 30 }
            .map(Person::name)
      ```
    * 위 예제 코드에서 ```filter```와 ```map```은 인라인 함수다.
    * 따라서 두 함수의 본문은 인라이닝되며, 추가 객체나 클래스 생성은 없다.
    * 일반 컬렉션의 경우 리스트를 걸러낸 결과를 저장하는 중간 리스트를 만든다.
    * 처리할 원소가 많아지면 중간 리스트를 사용하는 부가 비용도 걱정할 만큼 커진다.
    * ```asSequence```를 통해 리스트 대신 시퀀스를 사용하면 중간 리스트로 인한 부가 비용은 줄어든다.
    * 이때 각 중간 시퀀스는 람다를 필드에 저장하는 객체로 표현되며, 최종 연산은 중간 시퀀스에 있는 여러 람다를 연쇄 호출한다.
    * 따라서 시퀀스는 (람다를 저장해야 하므로) 람다를 인라이닝 하지 않는다.
    * ```시퀀스 연산에서는 람다가 인라이닝되지 않기 때문에 크기가 작은 컬렉션은 오히려 일반 컬렉션 연산이 더 성능이 나을 수도 있다.```
    * 시퀀스를 통해 성능을 향상시킬 수 있는 경우는 컬렉션 크기가 큰 경우뿐이다.
    <br>
    
  * **함수를 인라인으로 선언해야 하는 경우** 
    * ```inline``` 키워드를 사용해도 람다를 인자로 받는 함수만 성능이 좋아질 가능성이 높다.
    * 다른 경우에는 주의 깊게 성능을 측정하고 조사해봐야 한다.
    * 일반 함수 호출의 경우 JVM은 이미 강력하게 인라이닝을 지원한다.
    * JVM은 코드 실행을 분석해서 가장 이익이 되는 방향으로 호출을 인라이닝한다.
    * 이런 과정은 바이트코드를 실제 기계어 코드로 번역하는 과정(JIT)에서 일어난다.
    * 이런 JVM의 최적화를 활용한다면 바이트코드에서는 각 함수 구현이 정확히 한 번만 있으면 되고, 그 함수를 호출하는 부분에서 따로 함수 코드를 중복할 필요가 없다.
    * 반면 코틀린 인라인 함수는 바이트코드에서 각 함수 호출 지점을 함수 본문으로 대치하기 때문에 코드 중복이 생긴다. 
    * 람다를 인자로 받는 함수를 인라이닝하면 이익이 더 많다.
      * 함수 호출 비용을 줄일 수 있을 뿐 아니라 람다를 표현하는 클래스와 람다 인스턴스에 해당하는 객체를 만들 필요도 없어진다.
      * 현재의 JVM은 함수 호출과 람다를 인라이닝해 줄 정도로 똑똑하지는 못하다. 
      * 인라이닝을 사용하면 일반 람다에서는 사용할 수 없는 몇 가지 기능을 사용할 수 있다. 비로컬 반환(non-local return) 등
    * ```inline``` 변경자를 함수에 붙일 때는 코드 크기에 주의를 기울여야 한다.
      * ```인라이닝하는 함수가 큰 경우 함수의 본문에 해당하는 바이트코드를 모든 호출 지점에 복사해 넣고 나면 바이트코드가 전체적으로 아주 커질 수 있다.```
      * 그런 경우 람다 인자와 무관한 코드를 별도의 비인라인 함수로 빼낼 수도 있다.
      * 표준 라이브러리가 제공하는 ```inline``` 함수를 보면 모두 크기가 아주 작다.
      
