# HTTP가 보장하는 것들
 * 객체는 올바르게 식별되므로(```Content-Type``` 미디어 포맷과 ```Content-Language``` 헤더를 이용해서) 브라우저나 다른 클라이언트는 콘텐츠를 바르게 처리할 수 있다.
 </br>

 * 객체는 올바르게 압축이 풀릴 것이다(```Content-Length```와 ```Content-Encoding``` 헤더를 이용해서)
 </br>

 * 객체는 항상 최신이다(엔터티 검사기와 캐시 만료 제어를 이용해서)
 </br>

 * 사용자의 요구를 만족할 것이다(내용 협상을 위한 ```Accept``` 관련 헤더들에 기반하여)
 </br>

 * 네트워크 사이를 빠르고 효율적으로 이동할 것이다(범위 요청, 델타 인코딩, 그 외의 데이터 압축을 이용해서)
 </br>

 * 조작되지 않고 온전하게 도착할 것이다(전송 인코딩 헤더와 ```Content-MD5``` 체크섬을 이용해서)
 </br>

# 메시지는 컨테이너, 엔터티는 화물
 * HTTP 메시지를 인터넷 운송 시스템의 컨테이너라고 생각한다면, HTTP 엔터티는 메시지의 실질적인 화물이다.
 </br>

 * **HTTP/1.1의 주요 엔터티 헤더 필드**
   * ```Content-Type``` : 엔터티에 의해 전달된 객체의 종류(이미지, 텍스트 등)
   * ```Content-Length``` : 전달되는 메시지의 길이나 크기
   * ```Content-Language``` : 전달되는 객체와 가장 잘 대응되는 자연어
   * ```Content-Encoding``` : 객체 데이터에 대해 행해진 변형(압축 등)
   * ```Content-Location``` : 요청 시점을 기준으로, 객체의 또 다른 위치
   * ```Content-Range``` : 만약 이 엔터티가 부분 엔터티라면, 이 헤더는 이 엔터티가 전체에서 어느 부분에 해당하는지 정의한다. 
   * ```Content-MD5``` : 엔터티 본문의 콘텐츠에 대한 체크섬
   * ```Last-Modified``` : 서버에서 이 콘텐츠가 생성 혹은 수정된 날
   * ```Expires``` : 이 엔터티 데이터가 더 이상 신선하지 않은 것으로 간주되기 시작하는 날짜와 시각
   * ```Allow``` : 이 리소스에 대해 어떤 요청 메서드가 허용되는지. 예) ```GET과 HEAD```
   * ```ETag``` : 이 인스턴스에 대한 고유한 검사기. 엄밀히 말해 ```ETag``` 헤더는 엔터티 헤더로 정의되어 있지는 않지만 엔터티와 관련된 많은 동작을 위해 중요한 헤더이다.
   * ```Cache-Control``` : 어떻게 이 문서가 캐시 될 수 있는지에 대한 지시자. ```ETag``` 헤더와 마찬가지로 ```Cache-Control``` 헤더도 엔터티 헤더로 정의되어 있지는 않다.
 </br>

 * **엔터티 본문**
   * 엔터티 본문은 가공되지 않은 데이터만을 담고 있다. 
   * 다른 정보들은 모두 헤더에 담겨 있다. 
   * 엔터티 본문은 가공되지 않은 Raw 데이터에 불과하다.
   * 엔터티 본문은 헤더 필드의 끝을 의미하는 빈 ```CRLF``` 줄 바로 다음부터 시작한다.
 </br>

 # **Content-Length : 엔터티의 길이**
 * ```Content-Length``` 헤더는 메시지의 엔터티 본문의 크기를 바이트 단위로 나타낸다.
 </br>

 * 어떻게 인코딩 되었든 상관없이 크기를 표현할 수 있다. (```gzip```으로 압축된 텍스트 파일이라면 원래 크기가 아니라 압축된 후의 크기다)
 </br>

 * ```Content-Length``` 헤더는, 메시지를 청크 인코딩을 전송하지 않는 이상, 엔터티 본문을 포함한 메시지에서는 필수적으로 있어야 한다.
 </br>

 * ```Content-Length```는 서버 충돌로 인해 메시지가 잘렸는지 감지하고자 할 때와 지속 커넥션을 공유하는 메시지를 올바르게 분할하고자 할 때 필요하다.
 </br>

 * **잘림 검출**
   * 옛날 버전의 HTTP는 커넥션이 닫힌 것을 보고 메시지가 끝났음을 인지했음.
   * 하지만 ```Content-Length```가 없다면 커넥션이 정상 종료인지 비정상 종료인지 판단할 수 없음.
   * 클라이언트는 메시지 잘림을 검출하기 위해 ```Content-Length```를 필요로 한다. 
   * 캐싱 프락시 서버에서 특히 취약하기 때문에, 캐싱 프락시 서버는 명시적으로 ```Content-Length``` 헤더를 갖고 있지 않은 HTTP 본문은 캐싱 하지 않는다.
 </br>

 * **잘못된 ```Content-Length```**
   * 잘못된 ```Content-Length```는 빠진 것보다 더 큰 피해를 유발한다.
 <br>

 * **```Content-Length```와 지속 커넥션(Persistent Connection)**
   * ```Content-Length```는 지속 커넥션을 위해 필수
   * 지속 커넥션을 통해 HTTP 응답이 올 경우 ```Content-Length``` 헤더를 통해 메시지 하나가 어디서 끝나고 다음 메시지의 시작은 어디인지 알 수 있다.
   * 청크 인코딩을 사용할 때는 ```Content-Length``` 헤더 없이 지속 커넥션을 사용할 수 있다. 
 </br>

 * **콘텐츠 인코딩**
   * 본문의 콘텐츠가 압축과 같은 인코딩이 되어 있다면 ```Content-Length``` 헤더는 인코딩된 본문의 길이를 바이트 단위로 저장한다.
   * HTTP/1.1 명세에 서술된 어떤 헤더도 인코딩 되지 않은 원 본문의 길이를 보내기 위해 사용할 수 없다.
   * 그런 이유로 클라이언트가 자신이 수행한 디코딩 과정에 문제가 없었는지 검증하기 어렵게 만든다. 
 </br>

 * **엔터티 본문 길이 판별을 위한 규칙**
   * 본문을 갖는 것이 허용되지 않는 특정 타입의 HTTP 메시지에서는, 본문 계산을 위한 ```Content-Length``` 헤더가 무시된다.
     * 이 경우 ```Content-Length``` 헤더는 부가 정보에 불과하며, 실제 본문 길이를 서술하지 않는다.
     * 엔터티 본문을 금하는 메시지는 어떤 엔터티 헤더 필드가 존재하느냐와 상관없이 반드시 헤더 이후의 첫 번째 빈 줄에서 끝나야 한다. 
   * 메시지가 ```Transfer-Encoding``` 헤더를 포함하고 있다면 (기본 HTTP ```“identity”``` 인코딩과 다른), 메시지가 커넥션이 닫혀서 먼저 끝나지 않는 이상 엔터티는 ```‘0바이크 청크’```라 불리는 특별한 패턴으로 끝나야 한다. 
   * 메시지가 ```Content-Length``` 헤더를 갖는다면(그리고 메시지 유형이 엔터티 본문을 허용한다면), ```Transfer-Encoding``` 헤더가 존재하지 않는 이상 ```Content-Length``` 값은 본문의 길이를 담게 된다. 
     * 전송 인코딩은 엔터티 본문을 표현하고 전송하는 방식(그리고 아마 전송된 바이트 크기도)을 바꿀 것이기 때문에 ```Content-Length``` 헤더 필드와 identity가 아닌 ```Transfer-Encoding``` 헤더 필드를 갖고 있다면 ```Content-Length``` 헤더를 무시해야 한다. 
   * 메시지가 ```‘multipart/byteranges’``` 미디어 타입을 사용하고 엔터티 길이가 별도로 정의되지 않았다면, 멀티 파트 메시지의 각 부분은 각자 스스로의 크기를 정의할 것이다. 
     * 이 멀티 파트 유형은 자신의 크기를 스스로 결정할 수 있는 유일한 엔터티 본문 유형이다.
     * 이 미디어 타입은, 수신자가 이것을 해석할 수 있다는 사실을 송신자가 알기 전까지는 절대로 보내지 말아야 한다. 
     * 2014년 개정된 HTTP/1.1 명세인 RFC 7230에서 삭제되었기 때문에 최신 HTTP/1.1 명세를 따르는 애플리케이션은 이 규칙을 따르지 않을 수도 있다. 
   * 위의 어떤 규칙에도 해당되지 않는다면, 엔터티는 커넥션이 닫힐 때 끝난다. 
     * 오직 서버만이 메시지가 끝났음을 알리기 위해서 커넥션을 닫을 수 있다. 
   * HTTP/1.0 애플리케이션과 호환을 위해, 엔터티 본문을 갖고 있는 HTTP/1.1 요청은 반드시 유효한 ```Content-Length``` 헤더도 갖고 있어야 한다. 
   </br>

# 미디어 타입과 차셋(Charset)
  * ```Content-Type``` 헤더 필드는 엔터티 본문의 ```MIME``` 타입을 기술한다. 
  * ```MIME``` 타입은 전달되는 데이터 매체의 기저 형식(HTML 파일, 마이크로소프트 워드 문서, MPEG 비디오 등)의 표준화된 이름이다.
  * 클라이언트 애플리케이션은 콘텐츠를 적절히 해독하고 처리하기 위해 MIME 타입을 이용한다. 
  * **```Content-Type``` 헤더에서 흔히 쓰이는 ```MIME``` 타입**
    </br>
    
    | 미디어 타입 | 설명 |
    |:---|:---|
    | text/html | 엔터티 본문은 HTML 문서 |
    | text/plain | 엔터티 본문은 플레인 텍스트 문서 |
    | image/gif | 엔터티 본문은 GIF 이미지 |
    | image/jpeg | 엔터티 본문은 JPEG 이미지 |
    | audio/x-way | 엔터티 본문은 WAV 음향 데이터를 포함 |
    | model/vrml | 엔터티 본문은 삼차원 VRML 모델 |
    | application/vnd.ms-powerpoint | 엔터티 본문은 마이크로소프트 파워포인트 프레젠테이션 | 
    | multipart/byteranges | 엔터티 본문은 여러 부분으로 나뉘는데, 각 부분은 전체 문서의 특정 범위(바이트 단위)를 담고 있다. |
    | message/http | 엔터티 본문은 완전한 HTTP 메시지를 담고 있다. |
    </br>
    
  * **텍스트 매체를 위한 문자 인코딩**
    * ```Content-Type``` 헤더는 내용 유형을 더 자세히 지정하기 위한 선택적인 매개변수도 지원한다. 
    * 엔터티의 비트 집합을 텍스트 파일의 글자들로 변환하기 위한 ```charset``` 매개변수가 대표적인 예
    </br>
    
  * **멀티파트 미디어 타입**
    * ```MIME``` "멀티 파트" 이메일 메시지는 서로 붙어있는 여러 개의 메시지를 포함하며, 하나의 복합 메시지로 보내진다.
    * 각 구성요소는 자족적으로 자신에 대해 서술하는 헤더를 포함한다. 
    * 여러 구성요소들이 이어져 있고, 문자열 하나로 서로의 경계가 식별된다.
    </br>
    
  * **멀티 파트 폼 제출**
    * HTTP 폼을 채워서 제출하면, 가변 길이 텍스트 필드와 업로드될 객체는 각각이 멀티 파트 본문을 구성하는 하나의 파트가 되어 보내진다.
    * 멀티 파트 본문은 여러 다른 종류와 길이의 값으로 채워진 폼을 허용한다. 
    </br>
    
  * **멀티 파트 범위 응답**
    * 범위 요청에 대한 HTTP 응답 또한 멀티 파트가 될 수도 있다.
    * 그러한 응답은 ```Content-Type: multipart/byteranges``` 헤더 및 각각 다른 범위를 담고 있는 멀티 파트 본문이 함께 온다. 
    </br>
    
# 콘텐츠 인코딩
  * HTTP 애플리케이션은 때때로 콘텐츠를 보내기 전에 인코딩을 할 수 있다.
  * 예를 들어, 느린 속도로 연결된 클라이언트에게 큰 HTML 문서를 전송하기 전에 서버는 전송 시간을 줄이기 위해 압축을 할 수 있다. 
  * 콘텐츠를 암호화하거나 뒤섞어서 보낼 수도 있다.
  * **콘텐츠 인코딩 과정**
    * 웹 서버가 원본 ```Content-Type```과 ```Content-Length``` 헤더를 수반한 원본 응답 메시지를 생성
    * 콘텐츠 인코딩 서버(원 서버이거나 다운스트림 프락시일 것이다)가 인코딩된 메시지를 생성한다. 인코딩된 메시지는 ```Content-Type```은 같지만(본문이 압축되었거나 했다면) ```Content-Length```는 다르다. 콘텐츠 인코딩 서버는 ```Content-Encoding``` 헤더를 인코딩된 메시지에 추가하여, 수신 측 애플리케이션이 그것을 디코딩할 수 있도록 한다. 
    * 수신 측 프로그램은 인코딩된 메시지를 받아서 디코딩하고 원본을 얻는다.
    </br>
    
  * **콘텐츠 인코딩 유형**
    * HTTP는 몇 가지 표준 콘텐츠 인코딩 유형을 정의하고 확장 인코딩으로 인코딩을 추가하는 것도 허용한다.
    * 인코딩은 각 콘텐츠 인코딩 알고리즘에 고유한 토큰을 할당하는 ```IANA```를 통해 표준화된다. 
    * ```Content-Encoding``` 헤더는 이러한 표준화된 토큰값을 이용해서, 인코딩에 사용된 알고리즘들에 대해 기술한다. 
    * **자주 사용되는 인코딩 토큰**
    </br>
    
      | 콘텐츠 인코딩 값 | 설명 |
      |:---|:---|
      | gzip | 엔터티에 GNU zip 인코딩이 적용되었음을 의미한다. |
      | compress | 엔터티에 대해 유닉스 파일 압축 프로그램인 'compress'가 실행되었음을 의미한다. |
      | deflate | 엔터티가 zlib 포맷으로 압축되었음을 의미한다. |
      | identity | 엔터티에 어떤 인코딩도 수행되지 않았음을 의미한다. ```Content-Encoding``` 헤더가 존재하지 않는다면 이 값인 것으로 간주된다. |
    * ```gzip```, ```compress```, ```deflate``` 인코딩은 전송되는 메시지의 크기를 정보의 손실 없이 줄이기 위한 무손실 압축 알고리즘이다.
      * 이 중 gzip이 일반적으로 가장 효율적이고 가장 널리 쓰이는 압축 알고리즘이다.
    </br>
    
  * **Accept-Encoding 헤더**
    * 클라이언트가 해독할 수 없는 방법으로 서버가 콘텐츠를 인코딩하는 것을 원하지는 않는다.
    * 서버에서 클라이언트가 지원하지 않는 인코딩을 사용하는 것을 막기 위해, 클라이언트는 자신이 지원하는 인코딩의 목록을 ```Accept-Encoding``` 요청 헤더를 통해 전달한다. 
    * 만약 HTTP 요청에 ```Accept-Encoding``` 헤더를 포함하지 않는다면, 서버는 클라이언트가 어떤 인코딩이든 받아들일 수 있는 것으로 간주한다. 
      * ```Accept-Encoding:*```을 전달한 경우도 동일
      </br>
      
    * ```Accept-Encoding``` 필드는 지원되는 인코딩들의 쉼표로 구분된 목록을 담고 있다.
    * **```Accept-Encoding```을 사용하는 예**
      * ```Accept-Encoding: compress, gzip```
      * ```Accept-Encoding:```
      * ```Accept-Encoding:*```
      * ```Accept-Encoding: compress;q=0.5, gzip;q=1.0```
      * ```Accept-Encoding: gzip;q=1.0, identity;q=0.5, *;q=0```
      </br>
      
    * ```q```(Quality) 값을 매개변수로 선호도를 나타낼 수 있다.
    * ```q``` 값의 범위는 가장 원치 않음을 의미하는 ```0.0```에서 가장 선호함을 의미하는 ```1.0```까지다.
    * 토큰 ```*```은 '그 외 모두'를 의미한다. 
    </br>
    
# 전송 인코딩과 청크 인코딩
  * 콘텐츠 인코딩은 콘텐츠 포맷과 긴밀하게 연관되어 있다.
  * 텍스트 파일은 ```gzip```으로 압축하지만 JPEG는 ```gzip```으로 잘 압축되지 않기 때문에 그렇게 하지 않는다.
  * 전송 인코딩 또한 엔터티 본문에 적용되는 가역적 변환이지만, 그들은 구조적인 이유 때문에 적용되는 것이며 콘텐츠의 포맷과는 독립적이다.
  * **안전한 전송**
    * 역사적으로, 전송 인코딩은 다른 프로토콜에서도 네트워크를 통한 '안전한 전송'을 위해 존재했다.
    * 표준화되고 더 너그러운 전송 기반을 갖춘 HTTP는 '안전한 전송'의 초점을 다른 데에 맞추고 있다.
    * HTTP에서 전송된 메시지의 본문이 문제를 일으킬 수 있는 이유는 몇 가지 밖에 없다. 
      * **알 수 없는 크기**
        * 몇몇 게이트웨이 애플리케이션과 콘텐츠 인코더는 콘텐츠를 먼저 생성하지 않고서는 메시지 본문의 최종 크기를 판단할 수 없다. 
        * 흔히 이 서버들은 그 사이즈를 알기 전에 데이터의 전송을 시작하려고 하지만 HTTP는 데이터에 앞서 ```Content-Length```헤더를 요구하기 때문에, 몇몇 서버는 데이터의 끝을 알리는 특별한 종결 꼬리말을 포함시켜 전송 인코딩으로 데이터를 보내려 시도한다. 
        </br>
        
      * **보안**
        * 공용 전송 네트워크로 메시지 콘텐츠를 보내기 전에 전송 인코딩을 사용해 알아보기 어렵게 뒤섞어버리는 방법도 있다. 
        * 그러나 이미 ```SSL```과 같은 유명한 전송 계층 보안 방식이 있기 때문에 전송 인코딩 보안은 흔하지 않다.
        </br>
        
  * **```Transfer-Encoding``` 헤더**
    * 전송 인코딩을 제어하고 서술하기 위해 정의된 헤더는 단 두 개뿐이다.
    * **```Transfer-Encoding```**
      * 안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 수신자에게 알려준다.
      </br>
    * **```TE```**
      * 어떤 확장된 전송 인코딩을 사용할 수 있는지 서버에게 알려주기 위해 요청 헤더에 사용한다. 
      </br>
      
    * 모든 전송 인코딩 값은 대소문자가 구별된다.
    * HTTP/1.1은 ```Transfer-Encoding```과 ```TE``` 헤더 필드에 전송 인코딩 값을 사용한다. 
    * 최신 HTTP 명세는 오직 하나의 전송 인코딩, 즉 청크 인코딩만을 정의했다.
    * ```TE``` 헤더는 ```Accept-Encoding``` 헤더와 마찬가지로 어떤 형태의 전송 인코딩을 선호하는지 표현하는 ```q``` 값을 가질 수 있다. 그러나 HTTP/1.1 명세는 청크 인코딩에 대해 ```q``` 값이 ```0.0```을 갖는 것을 금지한다. 
    </br>
    
  * **청크 인코딩**
    * 청크 인코딩은 메시지를 일정 크기의 청크 여럿으로 쪼갠다. 
    * 청크 인코딩을 이용하면 메시지를 보내기 전엔 전체 크기를 알 필요가 없어진다. 
    * 본문이 동적으로 생성됨에 따라, 서버는 그중 일부를 버퍼에 담은 뒤 그 한 청크를 그것의 크기와 함께 보낼 수 있다. 
    * 본문 전체를 모두 보낼 때까지 이 단계를 반복한다.
    * 청크 인코딩은 전송 인코딩의 한 형태이며 본문의 속성인 멀티 파트 인코딩과 달리 메시지의 속성이다.
    * **청크와 지속 커넥션**
      * 클라이언트와 서버 사이의 커넥션이 지속적이지 않다면, 클라이언트는 자신이 읽고 있는 본문의 크기를 알 필요가 없다.
      * 지속 커넥션에서는, 본문을 쓰기 전에 반드시 ```Content-Length``` 헤더에 본문의 길이를 담아서 보내줘야 한다.
      * 콘텐츠가 서버에서 동적으로 생성되는 경우에는, 보내기 전에 본문의 길이를 알 수가 없다. 
      * 청크 인코딩은 서버가 본문을 여러 청크로 쪼개 보낼 수 있게 해줌으로써 이 딜레마에 대한 해법을 제공한다.
      * 동적으로 본문이 생성되면서, 서버는 그중 일부를 버퍼에 담은 뒤 그의 크기와 함께 보낼 수 있으며 본문을 모두 보낼 때까지 이 단계를 반복한다.
      * 크기가 0인 청크로 본문이 끝났음을 알리고 다음 응답을 위해 커넥션을 열린 채로 유지할 수 있다.
      </br>
      
      ![Alt text](/images/chunk_transfer.png "청크 인코딩된 메시지의 구조")
      </br>
      
    * **청크 인코딩된 메시지의 트레일러**
      * 다음 중 하나 이상의 조건을 만족하면 청크 메시지에 트레일러를 추가할 수 있다.
        * 클라이언트의 ```TE``` 헤더가 트레일러를 받아들일 수 있음을 나타내고 있는 경우
        * 트레일러가 응답을 만든 서버에 의해 추가되었으며, 그 트레일러의 콘텐츠는 클라이언트가 이해하고 사용할 필요가 없는 선택적인 메타데이터이므로 클라이언트가 무시하고 버려도 되는 경우
        </br>
      * 트레일러에는 본문의 콘텐츠가 먼저 생성되어야 한다거나 하는 등의 이유로 메시지 시작 시점에서는 그 값을 알 수 없는 추가적인 헤더 필드를 담을 수 있다.
      * 트레일러로 보낼 수 있는 헤더의 예로 ```Content-MD5``` 헤더가 있다(문서가 생성되기 전에 그 문서의 MD5를 계산하는 것은 어렵다)
      * ```Transfer-Encoding```, ```Trailer```, ```Content-Length```를 제외한 어떤 HTTP 헤더도 트레일러로 보낼 수 있다. 
      </br>
      
  * **전송 인코딩 규칙**
    * 전송 인코딩이 메시지 본문에 적용될 때 적용되어야 하는 규칙
      * 전송 인코딩의 집합은 반드시 ```chunked```를 포함해야 한다. 유일한 예외는 메시지가 커넥션의 종료로 끝나는 경우뿐이다.
      * 청크 전송 인코딩이 사용되었다면, 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야 한다. 
      * 청크 전송 인코딩은 반드시 메시지 본문에 한 번 이상 적용되어야 한다. 
      </br>
    * 전송 인코딩은 HTTP 버전 1.1에서 소개된 비교적 새로운 기능이다.
    * 전송 인코딩을 구현한 서버는 비 HTTP/1.1 애플리케이션에 전송 인코딩된 메시지를 보내지 않도록 주의해야 한다. 
    * 마찬가지로 만약 서버가 이해할 수 없는 전송 인코딩된 메시지를 받았다면, 서버는 ```501 Unimplemented``` 상태 코드로 응답해야 한다. 
    </br>
