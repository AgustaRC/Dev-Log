# HTTP가 보장하는 것들
* 객체는 올바르게 식별되므로(```Content-Type``` 미디어 포맷과 ```Content-Language``` 헤더를 이용해서) 브라우저나 다른 클라이언트는 콘텐츠를 바르게 처리할 수 있다.
</br>

* 객체는 올바르게 압축이 풀릴 것이다(```Content-Length```와 ```Content-Encoding``` 헤더를 이용해서)
</br>

* 객체는 항상 최신이다(엔터티 검사기와 캐시 만료 제어를 이용해서)
</br>

* 사용자의 요구를 만족할 것이다(내용 협상을 위한 ```Accept``` 관련 헤더들에 기반하여)
</br>

* 네트워크 사이를 빠르고 효율적으로 이동할 것이다(범위 요청, 델타 인코딩, 그 외의 데이터 압축을 이용해서)
</br>

* 조작되지 않고 온전하게 도착할 것이다(전송 인코딩 헤더와 ```Content-MD5``` 체크섬을 이용해서)
</br>

# 메시지는 컨테이너, 엔터티는 화물
* HTTP 메시지를 인터넷 운송 시스템의 컨테이너라고 생각한다면, HTTP 엔터티는 메시지의 실질적인 화물이다.
</br>

* **HTTP/1.1의 주요 엔터티 헤더 필드**
  * ```Content-Type``` : 엔터티에 의해 전달된 객체의 종류(이미지, 텍스트 등)
  * ```Content-Length``` : 전달되는 메시지의 길이나 크기
  * ```Content-Language``` : 전달되는 객체와 가장 잘 대응되는 자연어
  * ```Content-Encoding``` : 객체 데이터에 대해 행해진 변형(압축 등)
  * ```Content-Location``` : 요청 시점을 기준으로, 객체의 또 다른 위치
  * ```Content-Range``` : 만약 이 엔터티가 부분 엔터티라면, 이 헤더는 이 엔터티가 전체에서 어느 부분에 해당하는지 정의한다. 
  * ```Content-MD5``` : 엔터티 본문의 콘텐츠에 대한 체크섬
  * ```Last-Modified``` : 서버에서 이 콘텐츠가 생성 혹은 수정된 날
  * ```Expires``` : 이 엔터티 데이터가 더 이상 신선하지 않은 것으로 간주되기 시작하는 날짜와 시각
  * ```Allow``` : 이 리소스에 대해 어떤 요청 메서드가 허용되는지. 예) ```GET과 HEAD```
  * ```ETag``` : 이 인스턴스에 대한 고유한 검사기. 엄밀히 말해 ETag 헤더는 엔터티 헤더로 정의되어 있지는 않지만 엔터티와 관련된 많은 동작을 위해 중요한 헤더이다.
  * ```Cache-Control``` : 어떻게 이 문서가 캐시 될 수 있는지에 대한 지시자. ETag 헤더와 마찬가지로 ```Cache-Control``` 헤더도 엔터티 헤더로 정의되어 있지는 않다.
</br>

* **엔터티 본문**
  * 엔터티 본문은 가공되지 않은 데이터만을 담고 있다. 
  * 다른 정보들은 모두 헤더에 담겨 있다. 
  * 엔터티 본문은 가공되지 않은 Raw 데이터에 불과하다.
  * 엔터티 본문은 헤더 필드의 끝을 의미하는 빈 ```CRLF``` 줄 바로 다음부터 시작한다.
</br>

# **Content-Length : 엔터티의 길이**
* ```Content-Length``` 헤더는 메시지의 엔터티 본문의 크기를 바이트 단위로 나타낸다.
</br>

* 어떻게 인코딩 되었든 상관없이 크기를 표현할 수 있다. (```gzip```으로 압축된 텍스트 파일이라면 원래 크기가 아니라 압축된 후의 크기다)
</br>

* ```Content-Length``` 헤더는, 메시지를 청크 인코딩을 전송하지 않는 이상, 엔터티 본문을 포함한 메시지에서는 필수적으로 있어야 한다.
</br>

* ```Content-Length```는 서버 충돌로 인해 메시지가 잘렸는지 감지하고자 할 때와 지속 커넥션을 공유하는 메시지를 올바르게 분할하고자 할 때 필요하다.
</br>

* **잘림 검출**
  * 옛날 버전의 HTTP는 커넥션이 닫힌 것을 보고 메시지가 끝났음을 인지했음.
  * 하지만 ```Content-Length```가 없다면 커넥션이 정상 종료인지 비정상 종료인지 판단할 수 없음.
  * 클라이언트는 메시지 잘림을 검출하기 위해 ```Content-Length```를 필요로 한다. 
  * 캐싱 프락시 서버에서 특히 취약하기 때문에, 캐싱 프락시 서버는 명시적으로 ```Content-Length``` 헤더를 갖고 있지 않은 HTTP 본문은 캐싱 하지 않는다.
</br>

* **잘못된 Content-Length**
  * 잘못된 ```Content-Length```는 빠진 것보다 더 큰 피해를 유발한다.
<br>

* **Content-Length와 지속 커넥션(Persistent Connection)**
  * ```Content-Length```는 지속 커넥션을 위해 필수
  * 지속 커넥션을 통해 HTTP 응답이 올 경우 ```Content-Length``` 헤더를 통해 메시지 하나가 어디서 끝나고 다음 메시지의 시작은 어디인지 알 수 있다.
  * 청크 인코딩을 사용할 때는 ```Content-Length``` 헤더 없이 지속 커넥션을 사용할 수 있다. 
</br>

* **콘텐츠 인코딩**
  * 본문의 콘텐츠가 압축과 같은 인코딩이 되어 있다면 ```Content-Length``` 헤더는 인코딩된 본문의 길이를 바이트 단위로 저장한다.
  * HTTP/1.1 명세에 서술된 어떤 헤더도 인코딩 되지 않은 원 본문의 길이를 보내기 위해 사용할 수 없다.
  * 그런 이유로 클라이언트가 자신이 수행한 디코딩 과정에 문제가 없었는지 검증하기 어렵게 만든다. 
</br>

* **엔터티 본문 길이 판별을 위한 규칙**
  * 본문을 갖는 것이 허용되지 않는 특정 타입의 HTTP 메시지에서는, 본문 계산을 위한 ```Content-Length``` 헤더가 무시된다.
    * 이 경우 ```Content-Length``` 헤더는 부가 정보에 불과하며, 실제 본문 길이를 서술하지 않는다.
    * 엔터티 본문을 금하는 메시지는 어떤 엔터티 헤더 필드가 존재하느냐와 상관없이 반드시 헤더 이후의 첫 번째 빈 줄에서 끝나야 한다. 
  * 메시지가 ```Transfer-Encoding``` 헤더를 포함하고 있다면 (기본 HTTP ```“identity”``` 인코딩과 다른), 메시지가 커넥션이 닫혀서 먼저 끝나지 않는 이상 엔터티는 ```‘0바이크 청크’```라 불리는 특별한 패턴으로 끝나야 한다. 
  * 메시지가 ```Content-Length``` 헤더를 갖는다면(그리고 메시지 유형이 엔터티 본문을 허용한다면), ```Transfer-Encoding``` 헤더가 존재하지 않는 이상 ```Content-Length``` 값은 본문의 길이를 담게 된다. 
    * 전송 인코딩은 엔터티 본문을 표현하고 전송하는 방식(그리고 아마 전송된 바이트 크기도)을 바꿀 것이기 때문에 ```Content-Length``` 헤더 필드와 identity가 아닌 ```Transfer-Encoding``` 헤더 필드를 갖고 있다면 ```Content-Length``` 헤더를 무시해야 한다. 
  * 메시지가 ```‘multipart/byteranges’``` 미디어 타입을 사용하고 엔터티 길이가 별도로 정의되지 않았다면, 멀티 파트 메시지의 각 부분은 각자 스스로의 크기를 정의할 것이다. 
    * 이 멀티 파트 유형은 자신의 크기를 스스로 결정할 수 있는 유일한 엔터티 본문 유형이다.
    * 이 미디어 타입은, 수신자가 이것을 해석할 수 있다는 사실을 송신자가 알기 전까지는 절대로 보내지 말아야 한다. 
    * 2014년 개정된 HTTP/1.1 명세인 RFC 7230에서 삭제되었기 때문에 최신 HTTP/1.1 명세를 따르는 애플리케이션은 이 규칙을 따르지 않을 수도 있다. 
  * 위의 어떤 규칙에도 해당되지 않는다면, 엔터티는 커넥션이 닫힐 때 끝난다. 
    * 오직 서버만이 메시지가 끝났음을 알리기 위해서 커넥션을 닫을 수 있다. 
  * HTTP/1.0 애플리케이션과 호환을 위해, 엔터티 본문을 갖고 있는 HTTP/1.1 요청은 반드시 유효한 ```Content-Length``` 헤더도 갖고 있어야 한다. 
