# 함수
  * **너무 많은 인수**
    * 함수에서 인수 개수는 작을수록 좋다.
    * 아예 없으면 가장 좋다.
    * 넷 이상은 그 가치가 아주 의심스러우므로 최대한 피한다.
    <br>
    
  * **출력 인수**
    * 출력 인수는 직관에 위배한다.
    * 일반적으로 독자는 인수를 (출력이 아니라) 입력으로 간주한다.
    * 함수에서 뭔가의 상태를 변경해야 한다면 (출력 인수를 쓰지 말고) 함수가 속한 객체의 상태를 변경한다.
    <br>
    
  * **플래그 인수**
    * ```boolean``` 인수는 함수가 여러 기능을 수행한다는 명백한 증거다.
    * 플래그 인수는 혼란을 초래하므로 피해야 마땅하다.
    <br>
    
  * **죽은 함수**
    * 아무도 호출하지 않는 함수는 삭제한다.
    * 죽은 코드는 낭비다.
    * 과감히 삭제한다.
    <br>
    
# 일반
  * **한 소스 파일에 여러 언어를 사용한다**
    * 오늘날 프로그래밍 환경은 한 소스 파일에 다양한 언어를 지원한다.
    * 좋게 말하자면 혼란스럽고, 나쁘게 말하자면 조잡하다.
    * 이상적으로는 한 소스 파일이 한 언어만 사용하는 편이 가장 좋다.
    * 현실적으로 여러 언어가 불가피하지만 최대한 소스 파일에서 언어 수와 범위를 줄이도록 애써야 한다.
    <br>
   
  * **당연한 동작을 구현하지 않는다**
    * ```최소 놀람의 원칙(The Principle of Least Surprise)```에 의거해 함수나 클래스는 다른 프로그래머가 당연하게 여길 만한 동작과 기능을 제공해야 한다.
    * 당연한 동작을 구현하지 않으면 코드 독자와 코드 사용자가 더 이상 함수 이름만으로 함수 기능을 직관적으로 예상하기 어렵다.
    <br>
    
  * **경계를 올바로 처리하지 않는다**
    * 스스로의 직관에 의존하지 마라.
    * 부지런함을 대신할 지름길은 없다.
    * 모든 경계 조건을 찾아내고, 모든 경계 조건을 테스트하는 테스트 케이스를 작성하라.
    <br>
    
  * **안전 절차 무시**
    * 안전 절차를 무시하면 위험하다.
    * ```serialVersionUID```를 직접 제어할 필요가 있을지도 모르지만 그래도 직접 제어는 언제나 위험하다.
    * 컴파일러 경고 일부를 꺼버리면 빌드가 쉬워질진 모르지만 자치하면 끝없는 디버깅에 시달린다.
    * 실패하는 테스트 케이스를 일단 제쳐두고 나중으로 미루는 태도는 신용카드가 공짜 돈이라는 생각만큼 위험하다.
    <br>
    
  * **중복**
    * ```"한 번, 단 한 번만(Once, and only once)" - 켄트 벡```
    * 코드에서 중복을 발견할 때마다 추상화할 기회로 간주하라. 
    * 중복된 코드를 하위 루틴이나 다른 클래스로 분리하라.
    * 추상화로 중복을 정리하면 설계 언어의 어휘가 늘어난다. 
    * 똑같은 코드가 여러 차례 나오는 중복은 간단한 함수로 교체한다.
    * 여러 모듈에서 일련의 ```switch/case```나 ```if/else``` 문으로 똑같은 조건을 거듭 확인하는 중복은 다형성으로 대체해야 한다.
    * 알고리즘이 유사하나 코드가 서로 다른 중복은 템플릿 메소드 패턴이나 전략 패턴으로 중복을 제거한다. 
    * 어디서든 중복을 발견하면 없애라.
    <br>
  
  * **추상화 수준이 올바르지 못하다**
    * 추상화는 저차원 상세 개념에서 고차원 일반 개념을 분리한다.
    * 모든 저차원 개념은 파생 클래스에 넣고, 모든 고차원 개념은 기본 클래스에 넣는다. 
    * 예를 들어, 세부 구현과 관련한 상수, 변수, 유틸리티 함수는 기본 클래스에 넣으면 안 된다. 
    * 기본 클래스는 구현 정보에 무지해야 마땅하다.
    * 고차원 개념과 저차원 개념을 섞어서는 안 된다.
    <br>
    
  * **기본 클래스가 파생 클래스에 의존한다**
    * 개념을 기본 클래스와 파생 클래스로 나누는 가장 흔한 이유는 고차원 기본 클래스 개념을 저차원 파생 클래스 개념으로부터 분리해 독립성을 보장하기 위해서다.
    * 그러므로 기본 클래스가 파생 클래스를 사용한다면 뭔가 문제가 있다는 소리다.
    * 일반적으로 기본 클래스는 파생 클래스를 아예 몰라야 마땅하다.
    <br>
    
  * **과도한 정보**
    * 잘 정의된 모듈은 인터페이스가 작지만 작은 인터페이스로도 많은 동작이 가능하다.
    * 부실하게 정의된 모듈은 인터페이스가 구질구질하다. 그래서 간단한 동작 하나에도 온갖 인터페이스가 필요하다.
    * 잘 정의된 인터페이스는 많은 함수를 제공하지 않기 때문에 결합도가 낮다. 
    * 클래스가 제공하는 메서드 수는 적을수록 좋다.
    * 함수가 아는 변수 수도 작을수록 좋다. 
    * 클래스에 들어있는 인스턴스 변수 수도 작을수록 좋다.
    * 자료를 숨겨라. 
    * 유틸리티 함수를 숨겨라.
    * 상수와 임시 변수를 숨겨라.
    * 메서드나 인스턴스 변수가 넘쳐나는 클래스는 피하라.
    * 하위 클래스에서 필요하다는 이유로 ```protected``` 변수나 함수를 마구 생성하지 마라. 
    * 인터페이스를 매우 작게 그리고 매우 깐깐하게 만들어라. 정보를 제한해 결합도를 낮춰라.
    <br>
    
  * **죽은 코드**
    * 죽은 코드란 실행되지 않는 코드를 가리킨다.
    * 죽은 코드는 시간이 지나면 악취를 풍기기 시작한다.
    * 죽은 코드를 발견하면 바로 시스템에서 제거하라.
    <br>
    
  * **수평 분리**
    * 변수와 함수는 사용되는 위치에 가까이 정의한다.
    * 지역 변수는 처음으로 사용하기 직전에 선언하며 수평 범위(scope)가 짧아야 한다.
    * 선언한 위치로부터 몇 백 줄 아래에서 사용하면 안된다. 
    * ```private``` 함수는 처음으로 호출되는 위치를 찾은 후 조금만 아래로 내려가면 쉽게 눈에 띄어야 한다.
    <br>
    
  * **일관성 부족**
    * 어떤 개념을 한 방식으로 구현했다면 유사한 개념도 같은 방식으로 구현한다.
    * 표기법은 신중하게 선택하며, 일단 선택한 표기법은 신중하게 따른다. 
    * 한 함수에서 ```response```라는 변수에 ```HttpServeltResponse``` 인스턴스를 저장했다면 해당 객체를 사용하는 다른 함수에서도 일관성 있게 동일한 변수 이름을 사용한다. 
    * 이처럼 간단한 일관성만으로도 코드를 읽고 수정하기가 대단히 쉬워진다.
    <br>
    
  * **인위적 결합**
    * 서로 무관한 개념을 인위로 결합하지 않는다.
    * 예를 들어, 일반적인 ```enum```은 특정 클래스에 속할 이유가 없다.
    * ```enum```이 클래스에 속한다면 ```enum```을 사용하는 코드가 특정 클래스를 알아야만 한다. 
    * 범용 ```static``` 함수도 마찬가지로 특정 클래스에 속할 이유가 없다.
    * 일반적으로 인위적인 결합은 직접적인 상호작용이 없는 두 모듈 사이에 일어난다.
    * 함수, 상수, 변수를 선언할 때는 시간을 들여 올바른 위치를 고민한다.
    * 그저 당장 편한 곳에 선언하고 내버려두면 안 된다.
    <br>
    
  * **기능 욕심**
    * 클래스 메서드는 자기 클래스의 변수와 함수에 관시을 가져야지 다른 클래스의 변수와 함수에 관심을 가져서는 안 된다.
    * 메서드가 다른 객체의 참조자(Accessor)와 변경자(Mutator)를 사용해 그 객체 내용을 조작한다면 메서드가 그 객체 클래스의 범위를 욕심내는 탓이다.
    * 기능 욕심은 한 클래스의 속사정을 다른 클래스에 노출하므로, 별다른 문제가 없다면, 제거하는 편이 낫다. 
    <br>
    
  * **선택기 인수**
    * 선택기 인수(selector arguments)는 목적을 기억하기 어려울 뿐 아니라 각 인수가 여러 함수를 하나로 조합한다.
    * 선택기 인수는 큰 함수를 작은 함수 여럿으로 쪼개지 않으려는 게으름의 소산이다.
    * ```boolean``` 인수만이 문제는 아니고 ```enum```, ```int``` 등 함수 동작을 제어하려는 인수는 모두가 바람직하지 못하다. 
    * 일반적으로 인수를 넘겨 동작을 선택하는 대신 새로운 함수를 만드는 편이 낫다.
    <br>
    
  * **애매한 의도**
    * 코드를 짤 때는 의도를 최대한 분명히 밝힌다.
    * 행을 바꾸지 않고 표현한 수식, 헝가리식 표기법, 매직 번호 등은 모두 저자의 의도를 흐린다. 
    * 독자에게 의도를 분명히 표현하기 위해 시간을 투자할 가치가 있다.
    <br>
    
  * **부적절한 static 함수**  
    * ```Math.max(double a, double b)```는 좋은 ```static``` 메서드다.
    * 특정 인스턴스와 관련한 기능이 아니다.
    * ```new Math().max(a, b)```나 ```a.max(b)```라고 하면 오히려 우습다. 
    * ```max``` 메서드가 사용하는 정보는 두 인수가 전부다. 
    * 메서드를 소유하는 객체에서 가져오는 정보가 아니다. 
    * 결정적으로 ```Math.max``` 메서드를 재정의할 가능성은 거의 아니 전혀 없다. 
    * 간혹 우리는 ```static```으로 정의하면 안 되는 함수를 ```static```으로 정의한다. 
      ```java
      HourlyPayCalculator.calculatePay(employee, overtimeRate)
      ```
    * 특정 객체와 관련이 없으면서 모든 정보를 인수에서 가져오니까 언뜻 보면 ```static``` 함수로 적당하게 여겨진다.
    * 하지만 함수를 재정의할 가능성이 존재한다.
    * 수당을 계산하는 알고리즘이 여러 개일지도 모른다. 
    * 예를 들어, ```OvertimeHourlyPayCalculator```와 ```StraightTimeHourlyPayCalculator```를 분리하고 싶을지도 모른다. 
    * 그러므로 위 함수는 ```static``` 함수로 정의하면 안 된다.
    * ```Employee``` 클래스에 속하는 인스턴스 함수여야 한다. 
    * 보통 ```static``` 함수보다 인스턴스 함수가 더 낫다. 
    * 조금이라도 의심스럽다면 인스턴스 함수로 정의하고 반드시 ```static``` 함수로 정의해야겠다면 재정의할 가능성은 없는지 꼼꼼히 따져본다.
    <br>
    
  * **서술적 변수**
    * 프로그램 가독성을 높이는 가장 효과적인 방법 중 하나가 계산을 여러 단계로 나누고 중간 값으로 서술적인 변수 이름을 사용하는 방법이다.
      ```java
      Matcher match = headerPattern.matcher(line);
      if (match.find()) {
        String key = match.group(1);
        String value = match.group(2);
        headers.put(key.toLowerCase(), value);
      }
      ```
    * 서술적인 변수 이름을 사용한 탓에 첫 번째로 일치하는 그룹이 키```key```이고 두 번째로 일치하는 그룹이 값```value```라는 사실이 명확히 드러난다.
    * 서술적인 변수 이름은 많이 써도 괜찮다. 일반적으로는 많을수록 더 좋다.
    * 계산을 몇 단계로 나누고 중간 값에 좋은 변수 이름만 붙여도 해독하기 어렵던 모듈이 순식간에 읽기 쉬운 모듈로 탈바꿈한다.
    <br>
  
  * **이름과 기능이 일치하는 함수**
    * 다음 코드를 살펴보자.
      ```java
      Date newDate = date.add(5);
      ```
    * 5일을 더하는 함수인가? 아니면 5주? 5시간? ```date``` 인스턴스를 변경하는 함수인가? 아니면 예전 ```date``` 인스턴스는 그대로 두고 새로운 ```Date```를 반환하는 함수인가?
    * 코드만 봐서는 알 수가 없다.
    * ```date``` 인스턴스에 5일을 더해 ```date``` 인스턴스를 변경하는 함수라면 ```addDaysTo``` 혹은 ```increaseByDays```라는 이름이 낫다.
    * ```date``` 인스턴스는 변경하지 않으면서 5일 뒤인 새 날짜를 반환한다면 ```daysLater```나 ```daysSince```라는 이름이 낫다.
    * 이름만으로 분명하지 않아서 구현을 살피거나 문서를 뒤적여야 한다면 더 나은 이름으로 바꾸거나 아니면 더 나은 이름을 붙이기 쉽도록 기능을 정리해야 한다.
    <br>
  
  * **알고리즘을 이해하라**
    * 대다수 괴상한 코드는 사람들이 알고리즘을 충분히 이해하지 않은 채 코드를 구현한 탓이다.
    * 잠시 멈추고 실제 알고리즘을 고민하는 대신 여기저기 ```if``` 문과 플래그를 넣어보며 코드를 돌리는 탓이다.
    * 알고리즘을 안다고 생각하지만 실제로 코드가 `돌아갈` 때까지 이리저리 찔러보고 굴려본다.
    * 구현이 끝났다고 선언하기 전에 함수가 돌아가는 방식을 확실히 이해하는지 확인하라. 
    * 테스트 케이스를 모두 통과한다는 사실만으로는 부족하다.
    * 작성자가 알고리즘이 올바르다는 사실을 알아야 한다.
    * 알고리즘이 올바르다는 사실을 확인하고 이해하려면 기능이 뻔히 보일 정도로 함수를 깔끔하고 명확하게 재구성하는 방법이 최고다.
    * 코드가 돌아간다는 사실을 아는 것과 돌아가기 위한 알고리즘이 올바르다는 사실을 아는 것은 다르다.
    <br>
    
  * **논리적 의존성은 물리적으로 드러내라**
    * 한 모듈이 다른 모듈에 의존한다면 의존성은 물리적이어야 한다.
    * 논리적 의존성만으로는 부족하다. 
    * 의존하는 모듈이 상대 모듈에 대해 가정하면(즉, 논리적으로 의존하면) 안 된다.
    <br>
    
  * **If/Else 혹은 Switch/Case 문보다 다형성을 사용하라**
    * 대다수 개발자가 ```switch``` 문을 사용하는 이유는 그 상황에서 가장 올바른 선택이라서가 아니라 당장 손쉬운 선택이기 때문이다.
      * ```switch```를 선택하기 전에 다형성을 먼저 고려하라는 의미
    * 유형보다 함수가 더 쉽게 변하는 경우는 극히 드물다. 
      * 그러므로 모든 ```switch``` 문을 의심해야 한다.
    * `switch 문 하나` 규칙을 따른다. 
      * 선택 유형 하나에는 ```switch``` 문을 한 번만 사용하고 같은 선택을 수행하는 다른 코드에서는 다형성 객체를 생성해 ```switch``` 문을 대신한다.
    <br>
    
  * **매직 숫자는 명명된 상수로 교체하라**
    * 소프트웨어 개발에서 가장 오래된 규칙 중 하나
    * 어떤 상수는 이해하기 쉬우므로, 코드 자체가 자명하다면, 상수 뒤로 숨길 필요가 없다. 
    * `매직 숫자`라는 용어는 단지 숫자만 의미하지 않는다. 의미가 분명하지 않은 토큰을 모두 가리킨다.
    <br>
    
  * **관례보다 구조를 사용하라**
    * 설계 결정을 강제할 때는 규칙보다 관례를 사용한다. 
    * 명명 관례도 좋지만 구조 자체로 강제하면 더 좋다.
    * 예를 들어, ```enum``` 변수가 멋진 ```switch/case``` 문보다 추상 메소드가 있는 기본 클래스가 더 낫다. 
    * ```switch/case``` 문을 매번 똑같이 구현하라고 강제하기는 어렵지만, 파생 클래스는 추상 메서드를 모두 구현하지 않으면 안 되기 때문이다.
    <br>
  
  * **조건을 캡슐화하라**
    * 부울 논리는 (```if```나 ```while``` 문에다 넣어서 생각하지 않아도) 이해하기 어렵다.
    * 조건의 의도를 분명히 밝히는 함수로 표현하라. 
    * 예를 들어,
      ```java
      if (shouldBeDeleted(timer))
      ```
    * 위 코드가 다음 코드보다 낫다.
      ```java
      if (timer.hasExpired() && !timer.isRecurrent())
      ```
    <br>
  
  * **부정 조건은 피하라**
    * 부정 조건은 긍정 조건보다 이해하기 어렵다.
    * 가능하면 긍정 조건으로 표현한다. 
    * 예를 들면,
      ```java
      if (buffer.shouldCompact())
      ```
    * 위 코드가 아래 코드보다 낫다.
      ```java
      if (!buffer.shouldNotCompact())
      ```
    <br>
  
  * **함수는 한 가지만 해야 한다**
    * 함수를 짜다 보면 한 함수 안에다 여러 단락을 이어서 일련의 작업을 수행하고픈 유혹에 빠진다.
    * 이런 함수는 한 가지만 수행하는 함수가 아니다.
    * 예를 들어
      ```java
      public void pay() {
        for (Employee e : employees) {
          if (e.isPayDay()) {
            Money pay = e.calculatePay();
            e.deliverPay(pay);
          }
        }
      }
      ```
    * 위 코드는 세 가지를 수행한다.
    * 직원 목록을 루프로 돌면서, 각 직원의 월급일을 확인해서, 해당 직원에게 월급을 지급한다. 
    * 위 함수는 다음 함수 셋으로 나누는 편이 낫다.
      ```java
      public void pay() {
        for (Employee e : employees) {
          payIfNecessary(e);
        }
      }

      private void payIfNecessary(Employee e) {
        if (e.isPayDay()) {
          canculateAndDeliverPay(e);
        }
      }

      private void calculateAndDeliverPay(Employee e) {
        Money pay = e.calculatePay();
        e.deliverPay(pay);
      }
      ```
    <br>
  
  * **숨겨진 시간적인 결합**
    * 때로는 시간적인 결합이 필요하다.
    * 하지만 시간적인 결합을 숨겨서는 안 된다.
    * 함수를 짤 때는 함수 인수를 적절히 배치해 함수가 호출되는 순서를 명백히 드러낸다. 
      ```java
      public class MoogDiver {
        Gradient gradient;
        List<Spline> splines;

        public void dive(String reason) {
          saturateGradient();
          reticulateSplines();
          diveForMoog(reason);
        }

        ...
      }
      ```
    * 위 코드에서 세 함수가 실행되는 순서는 중요하다. 
    * ```gradient```를 처리하기 위해 ```saturateGradient()```를 호출한 다음에 ```splines```를 처리하기 위해 ```reticulateSplines()```를 호출한 다음에 마지막으로 ```diveForMoog()```를 수행해야 한다. 
    * 불행하게도 위 코드는 이런 시간적인 결합을 강제하지 않는다.
    * 프로그래머가 ```reticulateSplines```를 호출하고 ```saturateGradient```를 호출해서 ```UnsaturatedGradientException``` 오류가 발생해도 막을 도리가 없다. 
    * 다음 코드가 더 낫다.
      ```java
      public class MoogDiver {
        Gradient gradient;
        List<Spline> splines;

        public void dive(String reason) {
          Gradient gradient = saturateGradient();
          List<Spline> splines = reticulateSplines(gradient);
          diveForMoog(splines, reason);
        }

        ...
      }
      ```
    * 위 코드는 일종의 연결 소자를 생성해 시간적인 결합을 노출한다.
    * 각 함수가 내놓는 결과는 다음 함수에 필요하다. 그러므로 순서를 바꿔서 호출할 수가 없다.
    <br>
    
  * **일관성을 유지하라**
    * 코드 구조를 잡을 때는 이유를 고민하라.
    * 그리고 그 이유를 코드 구조로 명백히 표현하라.
    * 구조에 일관성이 없어 보인다면 남들이 맘대로 바꿔도 괜찮다고 생각한다.
    * 시스템 전반에 걸쳐 구조가 일관성이 있다면 남들도 일관성을 따르고 보존한다.
    <br>
    
  * **경계 조건을 캡슐화하라**
    * 경계 조건은 빼먹거나 놓치기 십상이다.
    * 경계 조건은 한 곳에서 별도로 처리한다.
    * 코드 여기저기에서 처리하지 않는다. 
    * 아래 코드를 보자.
      ```java
      if (level + 1 < tags.length) {
        parts = new Parse(body, tags, level + 1, offset + endTag);
      }
      ```
    * 위 코드에서 ```level + 1```이 두 번 나온다. 이런 경계 조건은 변수로 캡슐화하는 편이 낫다. 
      ```java
      int nextLevel = level + 1;
      if (nextLevel < tags.length) {
        parts = new Parse(body, tags, nextLevel, offset + endTag);
      }
      ```
    <br>
  
  * **함수는 추상화 수준 한 단계만 내려가야 한다**
    * 함수 내 모든 문장은 추상화 수준이 동일해야 한다.
    * 그리고 그 추상화 수준은 함수 이름이 의미하는 작업보다 한 단계만 낮아야 한다.
    * 추상화 수준 분리는 리팩토링을 수행하는 가장 중요한 이유 중 하나다. 
    <br>
    
  * **구성 정보는 최상위 단계에 두어라**
    * 추상화 최상위 단계에 두어야 할 기본값 상수나 구성 상수를 저차원 함수에 숨겨서는 안 된다.
    * 대신 초가원 함수에서 저차원 함수를 호출할 때 인수로 넘긴다. 
    * 아래 예제를 살펴보자.
      ```java
      public static void main(String[] args) throws Eception {
        Arguments arguments = parseCommandLine(args);
      }

      public class Arguments {
        public static final String DEFAULT_PATH = ".";
        public static final String DEFAULT_ROOT = "FitNesseRoot";
        public static final int DEFAULT_PORT = 80;
        public static final int DEFAULT_VERSION_DAYS = 14;
        ...
      }
      ```
    * 위 코드에서 첫 행은 명령행 인수의 구문을 분석한다.
    * 각 인수 기본값은 ```Argument``` 클래스 맨 처음에 나온다. 
    * 다음과 같은 코드를 찾아서 시스템의 저수준을 뒤질 필요가 없다.
      ```java
      if (arguments.port == 0) // 기본값으로 80을 사용한다.
      ```
    * 구성 상수는 최상위 단계에 둔다. 
    * 그래야 변경하기도 쉽다.
    * 구성 변수는 나머지 코드에 인수로 넘긴다. 저차원 함수에 상수 값을 정의하면 안 된다.
    <br>
    
  * **추이적 탐색을 피하라**
    * 일반적으로 한 모듈은 주변 모듈을 모를수록 좋다.
    * 좀더 구체적으로, ```A```가 ```B```를 사용하고 ```B```가 ```C```를 사용한다고 ```A```가 ```C```를 알아야 할 필요는 없다는 뜻이다(예를 들어, ```a.getB().getC().doSomething();```은 바람직하지 못하다)
    * 이를 ```디미터의 법칙(Law of Demeter)```이라 부른다.
    * 실용주의 프로그래머들은 ```부끄럼 타는 코드 작성(Writing Shy Code)```이라고도 한다. 
    * 무엇이라 부르든 요지는 자신이 직접 사용하는 모듈만 알아야 한다는 뜻이다.
    * 많은 모듈이 ```a.getB().getC()```라고 사용한다면 설계와 아키텍처를 바꿔서 B와 C 사이에 Q를 넣기가 쉽지 않다.
    * ```a.getB().getC()```를 모두 찾아 ```a.getB().getQ().getC()```로 바꿔야 하니까.
    * 너무 많은 모듈이 아키텍처를 너무 많이 안다. 그래서 아키텍처가 굳어진다.
    <br>
    
# 이름
  * **서술적인 이름을 사용하라**
    * 이름은 성급하게 정하지 않는다.
    * 소프트웨어가 진화하면 의미도 변하므로 선택한 이름이 적합한지 자주 다시 돌아본다. 
    * 소프트웨어 가독성의 ```90%```는 이름이 결정한다.
    * 그러므로 시간을 들여서 현명한 이름을 서낵하고 유효한 상태로 유지한다. 
    * 신중하게 선택한 이름은 추가 설명을 포함한 코드보다 강력하다.
    <br>
    
  * **적절한 추상화 수준에서 이름을 선택하라**
    * 구현을 드러내는 이름을 피하라.
    * 작업 대상 클래스나 함수가 위치하는 추상화 수준을 반영하는 이름을 선택하라.
    * 코드를 살펴볼 때마다 추상화 수준이 너무 낮은 변수 이름을 발견하면 발견할 때마다 기회를 잡아서 바꿔놓아야 한다.
    * 안정적인 코드를 만들려면 지속적인 개선과 노력이 필요하다.
    * 다음 Modem 인터페이스를 살펴보자.
      ```java
      public interface Modem {
        boolean dial(String phoneNumber);
        boolean disconnect();
        boolean send(char c);
        char recv();
        String getConnectedPhoneNumber();
      }
      ```
    * 얼핏 봐서는 문제가 없다. 
    * 함수는 모두 적절해 보인다. 사실상 대다수 응용 프로그램에서는 문제가 없다.
    * 하지만 일부 모뎀이 전화선에 연결되지 않는 응용 프로그램을 생각해보자.
    * 일부는 USB로 연결된 스위치에 포트 번호를 보낼지도 모른다.
    * 그렇다면 전화번호라는 개념은 확실히 추상화 수준이 틀렸다. 
    * 더 나은 `이름 선택` 전략은 다음과 같다.
      ```java
      public interface Modem {
        boolean connect(String connectionLocator);
        boolean disconnect();
        boolean send(char c);
        char recv();
        String getConnectedLocator();
      }
      ```
    * 위 코드는 연결 대상의 이름을 더 이상 전화번호로 제한하지 않는다. 전화번호는 물론이고 다른 연결 방식에도 사용이 가능해진다.
    <br>
    
  * **가능하다면 표준 명명법을 사용하라**
    * 기존 명명법을 사용하는 이름은 이해하기 더 쉽다. 
    * 예를 들어, 데코레이터 패턴을 사용한다면 장식하는 클래스 이름에 ```Decorator```라는 단어를 사용한다.
    * 예를 들어, ```AutoHangupModemDecorator```는 세션 끝 무렵에 자동으로 연결을 끊으면서 Modem을 장식하는 클래스 이름으로 적합하다.
    * 패턴은 한 가지 표준에 불과하다. 
    * 예를 들어 자바에서 객체를 문자열로 반환하는 함수는 ```toString```이라는 이름을 많이 쓴다. 이런 이름은 (새로 만들어내기보다) 관례를 따르는 편이 낫다.
    * 흔히 팀은 특정 프로젝트에 적용할 표준을 나름대로 고안한다. 에릭 에반스는 이를 ```프로젝트의 편재적인 언어(Ubiquitous Language)```라고 부른다.
    * 코드는 이 언어에 속하는 용어를 열심히 써야 한다. 간단히 말해, 프로젝트 의미가 담긴 이름을 많이 사용할수록 독자가 코드를 이해하기 쉬워진다.
    <br>
    
  * **긴 범위는 긴 이름을 사용하라**
    * 이름 길이는 범위 길이에 비례해야 한다. 
    * 범위가 작으면 아주 짧은 이름을 사용해도 괜찮다. 하지만 범위가 크면 긴 이름을 사용한다.
    * 범위가 5줄 안팎이라면 ```i```나 ```j```와 같은 변수 이름도 괜찮다. 
      ```java
      private void rollMany(int n, int pins) {
        for (int i = 0; i < n; i++) {
          g.roll(pins);
        }
      }
      ```
    * 깔끔한 코드다. 오히려 변수 ```i```를 ```rollCount```라고 썼다면 헷갈릴 터이다. 
    * 반면, 이름이 짧은 변수나 함수는 범위가 길어지면 의미를 잃는다. 그러므로 이름 범위가 길수록 이름을 정확하고 길게 짓는다. 
    <br>
    
  * **이름으로 부수 효과를 설명하라**
    * 함수, 변수, 클래스가 하는 일을 모두 기술하는 이름을 사용한다.
    * 이름에 부수 효과를 숨기지 않는다.
    * 실제로 여러 작업을 수행하는 함수에다 동사 하나를 달랑 사용하면 곤란하다.
    * 다음은 TestNG에서 가져온 코드다.
      ```java
      public ObjectOutputStream getOos() throws IOException {
        if (oos == null) {
          oos = new ObjectOutputStream(socket.getOutputStream());
        }

        return oos;
      }
      ```
    * 위 함수는 단순히 ```oos```만 가져오지 않는다.
    * 기존에 ```oos```가 없으면 생성한다. 그러므로 ```createOrReturnOos```라는 이름이 더 낫다.
    <br>

# 테스트
  * **불충분한 테스트**
    * 테스트 케이스는 몇 개나 만들어야 충분할까?
    * 테스트 케이스는 잠재적으로 깨질 만한 부분을 모두 테스트해야 한다.
    * 테스트 케이스가 확인되지 않는 조건이나 검증하지 않는 계산이 있다면 그 테스트는 불완전하다.
    <br>
    
  * **무시한 테스트는 모호함을 뜻한다**
    * 때로는 요구사항이 불분명하기에 프로그램이 돌아가는 방식을 확신하기 어렵다.
    * 불분명한 요구사항은 테스트 케이스를 주석으로 처리하거나 테스트 케이스에 @Ignore를 붙여 표현한다.
    * 선택의 기준은 모호함이 존재하는 테스트 케이스가 컴파일이 가능한지 불가능한지에 달려있다.
    <br>
    
  * **경계 조건을 테스트하라**
    * 경계 조건은 각별히 신경 써서 테스트한다.
    * 알고리즘 가운데는 올바로 짜놓고 경계에서 실수하는 경우가 흔하다.
    <br>
  
  * **버그 주변은 철저하게 테스트하라**
    * 버그는 서로 모이는 경향이 있다.
    * 한 함수에서 버그를 발견했다면 그 함수를 철저히 테스트하는 편이 좋다. 십중팔구 다른 버그도 발견하리라.
    <br>
    
  * **실패 패턴을 살펴라**
    * 때로는 테스트 케이스가 실패하는 패턴으로 문제를 진단할 수 있다.
    * 테스트 케이스를 최대한 꼼꼼히 짜라는 이유도 여기에 있다.
    * 꼼꼼한 테스트 케이스는, 합리적인 순서로 정렬하면, 패턴이 드러난다. 
    * 간단한 예로, 입력이 5자를 넘기는 테스트 케이스가 모두 실패한다면? 함수 둘째 인수로 음수를 넘기는 테스트 케이스가 실패한다면?
    * 때로는 테스트 보고서에서 빨간색/녹색 패턴만 보고도 "아!"라는 깨달음을 얻는다. 
    <br>
    
  * **테스트는 빨라야 한다**
    * 느린 테스트 케이스는 실행하지 않게 된다.
    * 일정이 촉박하면 느린 테스트 케이스를 제일 먼저 건너뛴다.
    * 그러므로 테스트 케이스가 빨리 돌아가도록 최대한 노력한다.
