# 개별 접촉
* HTTP는 익명으로 사용하며 상태가 없고, 요청과 응답으로 통신하는 프로토콜
</br>

* 연결 자체에 대한 정보를 가지지 않으며 매 요청은 일회성이고 독립적으로 처리되는 HTTP의 특성을 ```Stateless```라고 한다. 
</br>

* HTTP 트랜잭션은 상태가 없기 때문에 각 요청 및 응답은 독립적으로 일어난다. 많은 웹사이트에서 사용자가 사이트와 상호작용할 수 있게 사용자의 상태를 남긴다. 
</br>

* **HTTP가 사용자를 식별하는데 사용하는 기술**
  * 사용자 식별 관련 정보를 전달하는 HTTP 헤더들
  * 클라이언트 IP 주소 추적으로 알아낸 IP 주소로 사용자를 식별
  * 사용자 로그인 인증을 통한 사용자 식별
  * URL에 식별자를 포함하는 기술인 뚱뚱한(fat) URL
  * 식별 정보를 지속해서 유지하는 강력하면서도 효율적인 기술인 쿠키
</br>

# HTTP 헤더
* **사용자에 대한 정보를 전달하는 가장 일반적인 HTTP 요청 헤더**
  * ```From``` : 사용자의 이메일 주소
  * ```User-Agent``` : 사용자의 브라우저
  * ```Referer``` : 사용자가 현재 링크를 타고 온 근원 페이지
  * ```Authorization``` : 사용자 이름과 비밀번호
  * ```Client-ip``` : 클라이언트의 IP 주소
  * ```X-Forwarded-For``` : 클라이언트의 IP 주소
  * ```Cookie``` : 서버가 생성한 ID 라벨
</br>  

# 클라이언트 IP 주소
* 웹 서버가 요청마다 클라이언트의 IP를 알 수 있다면 문제없이 동작한다.
</br>

* 클라이언트의 IP 주소는 보통 HTTP 헤더에 없지만 웹 서버는 HTTP 요청을 보내는 반대쪽 TCP 커넥션의 IP 주소를 알아낼 수 있다. 
</br>

* **클라이언트 IP 주소로 사용자를 식별하는 방식의 약점**
  * 클라이언트 IP 주소는 사용자가 아닌, 사용하는 컴퓨터를 가리킨다. 만약 여러 사용자가 같은 컴퓨터를 사용한다면 그들을 식별할 수 없다. 
  * 많은 인터넷 서비스 제공자(ISP)는 사용자가 로그인하면 동적으로 IP 주소를 할당한다. 로그인한 시간에 따라, 사용자는 매번 다른 주소를 받으므로, 웹 서버는 사용자를 IP 주소로 식별할 수 없다. 
  * 보안을 강화하고 부족한 주소들을 관리하려고 많은 사용자가 네트워크 주소 변환(NAT) 방화벽을 통해 인터넷을 사용한다. **이 NAT 장비들은 클라이언트의 실제 IP 주소를 방화벽 뒤로 숨기고, 클라이언트의 실제 IP 주소를 내부에서 사용하는 하나의 방화벽 IP주소로 변환한다.** 
  * 보통, HTTP 프락시와 게이트웨이는 원 서버에 새로운 TCP 연결을 한다. 웹 서버는 클라이언트의 IP 주소 대신 프락시 서버의 IP 주소를 본다. 
</br>

# 사용자 로그인
* 웹 사이트 로그인이 더 쉽도록 HTTP는 ```WWW-Authenticate```와 ```Authorization``` 헤더를 사용해 웹 사이트에 사용자 이름을 전달하는 자체적인 체계를 가지고 있다. 
</br>

* 서버에서, 사용자가 사이트에 접근하기 전에 로그인을 시키고자 한다면 HTTP 401 응답 코드를 브라우저에 보낼 수 있다. 
</br>

* 사용자가 로그인하면 다음 요청부터 ```Authorization``` 헤더에 그 정보를 기술하여 보낸다. 
</br>

* 사용자는 사이트마다 서로 다른 사용자 이름과 비밀번호를 기억해야 하고 사용자 이름과 비밀번호는 원한다면 누구나 작은 노력으로 쉽게 해독할 수 있다. 
</br>

# 뚱뚱한 URL
* 사용자의 상태 정보를 포함하고 있는 URL
</br>

* 사용자가 웹 사이트에 처음 방문하면 유일한 ID가 생성되고, 그 값은 서버가 인식할 수 있는 방식으로 URL에 추가되며, 서버는 클라이언트를 이 뚱뚱한 URL로 리다이렉트 시킨다. 
</br>

* 서버가 뚱뚱한 URL을 포함한 요청을 받으면, 사용자 아이디와 관련된 추가적인 정보(쇼핑 카트, 프로필 등)를 찾아서 밖으로 향하는 모든 하이퍼링크를 뚱뚱한 URL로 바꾼다. 
</br>

* **문제점**
  * 브라우저에 보이는 뚱뚱한 URL은 새로운 사용자들에게 혼란을 준다. 
  * 특정 사용자와 세션에 대한 상태 정보를 포함하기 때문에 만약 그 주소를 누군가에게 메일로 보내면, 누적된 개인 정보를 본의 아니게 공유하게 되는 것이다. 
  * URL이 달라지기 때문에 기존 캐시에 접근할 수 없다. 
  * 뚱뚱한 URL에 해당하는 HTML 페이지를 다시 그려야 하기 때문에 서버에 부하가 가중된다. 
  * 사용자가 링크를 타고 다른 사이트로 이동하거나 특정 URL을 요청해서 의도치 않게 뚱뚱한 URL 세션에서 이탈하기 쉽다. 
  * 사용자가 뚱뚱한 URL을 북마킹하지 않는 이상, 로그아웃하면 모든 정보를 잃는다. 
</br>

# 쿠키
* 사용자를 식별하고 세션을 유지하는 방식 중에서 현재까지 가장 널리 사용하는 방식
</br>

* 넷스케이프가 최초로 개발했지만, 지금은 모든 브라우저에서 지원한다. 
</br>

* 캐시와 충돌할 수 있어서, 대부분의 캐시나 브라우저는 쿠키에 있는 **내용물**을 캐싱 하지 않는다.
</br>

* **쿠키의 타입**
  * ```세션 쿠키(session cookie)```
    * 사용자가 사이트를 탐색할 때, 관련한 설정과 선호 사항들을 저장하는 임시 쿠키
    * 사용자가 브라우저를 닫으면 삭제된다. 
  * ```지속 쿠키(persistent cookie)```
    * 디스크에 저장되어, 브라우저를 닫거나 컴퓨터를 재시작 하더라도 남아 있다. 
    * 사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름을 유지하려고 사용
  * 세션 쿠키와 지속 쿠키의 다른 점은 파기되는 시점뿐이다.
</br>

* **쿠키는 어떻게 동작하는가**
  * 처음에 사용자가 웹 사이트에 방문하면 웹 서버는 사용자에 대해서 아무거도 모른다. 
  * 웹 서버는 사용자가 다시 돌아왔을 때, 해당 사용자를 식별하기 위한 유일한 값을 쿠키에 할당한다.
  * 이름=값 형태의 리스트를 가지고 ```Set-Cookie```, ```Set-Cooikie2``` 같은 HTTP 응답 헤더에 기술하여 사용자에게 전달
  * 어떤 정보든 포함할 수 있지만, 서버가 사용자 추적 용도로 생성한 유일한 단순 식별 번호만 포함하기도 한다. 
  * 브라우저는 서버로 온 ```Set-Cookie``` 혹은 ```Set-Cookie2``` 헤더에 있는 쿠키 콘텐츠를 브라우저 쿠키 데이터베이스에 저장한다. 
  * 사용자가 같은 사이트를 방문하면 브라우저는 서버가 이 사용자에게 할당했던 쿠키를 Cookie 요청 헤더에 기술해 전송한다. 
</br>

* **쿠키 상자 : 클라이언트 측 상태**
  * 쿠키의 기본적인 발상은 브라우저가 서버 관련 정보를 저장하고, 사용자가 해당 서버에 접근할 때마다 그 정보를 함께 전송하게 하는 것
  * 브라우저는 쿠키 정보를 저장할 책임이 있는데, 이 시스템을 ```‘클라이언트 측 상태’```라고 한다.
  * 각 브라우저는 각기 다른 방식으로 쿠키를 저장한다. 구글 크롬은 Cookies라는 ```SQLite``` 파일에 쿠키를 저장한다.
  * 구글 크롬 쿠키
    * ```creation_utc``` : 쿠키가 생성된 시점, Jan 1, 1970 00:00:00 GMT로부터 생성된 시간을 초 단위로 기술
    * ```host_key``` : 쿠키의 도메인
    * ```name``` : 쿠키의 이름
    * ```value``` : 쿠키의 값
    * ```path``` : 쿠키와 관련된 도메인에 있는 경로
    * ```expire_utc``` : 쿠키의 파기 시점, Jan 1, 1970 00:00:00 GMT로부터 파기될 시간을 초 단위로 기술
    * ```secure``` : 이 쿠키를 SSL 커넥션일 경우에만 보낼지를 가리킨다.
</br>

* **사이트마다 각기 다른 쿠키들**
  * 브라우저는 수백수천 개의 쿠키를 가지고 있을 수 있지만, 보통 각 사이트에 두 개 혹은 세 개의 쿠키만을 보낸다. 
    * 쿠키를 모두 전달하면 성능이 크게 저하됨.
    * 쿠키들 대부분은 서버에 특화된 이름/값 쌍을 포함하고 있기 때문에, 대부분 사이트에서는 인식하지 않는 무의미한 값
    * 모든 사이트에 쿠키 전체를 전달하는 것은, 특정 사이트에서 제공한 정보를 신뢰하지 않는 사이트에서 가져갈 수 있어서 잠재적인 개인 정보 문제를 일으킨다. 
  * 보통 브라우저는 쿠키를 생성한 서버에게만 쿠키에 담긴 정보를 전달한다. 
  * 광고들은 웹 사이트 자체의 일부인 것처럼 제작되고, 지속 쿠키를 만들어낸다. 같은 광고사에서 제공하는 서로 다른 웹 사이트에 사용자가 방문하면, 브라우저는 앞서 만든 지속 쿠키를 다시 광고사 서버로 전송한다. 이는 지속 쿠키의 도메인이 같기 때문이다. 
 </br>
 
* **쿠키 Domain 속성**
  * 서버가 쿠키를 생성할 때 ```Set-Cookie``` 응답 헤더에 Domain 속성을 기술해서 어떤 사이트가 그 쿠키를 읽을 수 있는지 제어할 수 있다. 
</br>

* **쿠키 Path 속성**
  * 웹 사이트 일부에만 쿠키를 적용할 수도 있다. 
  * URL 경로의 앞부분을 가리키는 Path 속성을 기술해서 해당 경로에 속하는 페이지에만 쿠키를 전달한다. 
</br>

* **쿠키 구성요소**
  * ```Set-Cookie```는 응답 헤더
  * ```Cookie```는 요청 헤더
</br>

* **쿠키와 캐싱**
  * 쿠키 트랜잭션과 관련된 문서를 캐싱 하는 것은 주의해야 한다.
  * 이전 사용자의 쿠키가 다른 사용자에게 할당돼버리거나, 누군가의 개인 정보가 다른 이에게 노출되는 상황이 발생할 수 있음.
</br>

* **쿠키 캐시를 다루는 기본 원칙**
  * 캐시 되지 말아야 할 문서가 있다면 표시하라
    * 만약 문서가 ```Set-Cookie``` 헤더를 제외하고 캐시를 해도 될 경우라면 그 문서에 명시적으로 ```Cache-Control: no-cache=“Set-Cookie”```를 기술해서 명확히 표시한다. 
  * Set-Cookie 헤더를 캐시 하는 것에 유의하라
    * 같은 ```Set-Cookie``` 헤더를 여러 사용자에게 보내게 되면, 사용자 추적에 실패할 것이다. 
    * 어떤 캐시는 응답을 저장하기 전에 ```Set-Cookie``` 헤더를 제거하기 때문에, 그 캐시 데이터를 받는 클라이언트는 ```Set-Cookie``` 헤더 정보가 없는 데이터를 받게 되어 문제가 발생할 수 있다. 
    * 캐시가 모든 요청마다 원 서버와 재검사시켜 클라이언트로 가는 응답에 Set-Cookie 헤더 값을 기술해서 이 문제를 개선할 수 있다. 
    * 원 서버는 다음과 같은 헤더를 캐시 된 문서에 추가함으로써 재검사가 일어나게 할 수 있다.
    * ```Cache-Control: must-revalidate, max-age=0```
  * Cookie 헤더를 가지고 있는 요청을 주의하라
    * 요청이 ```Cookie``` 헤더와 함께 오면, 결과 콘텐츠가 개인 정보를 담고 있을 수도 있다는 힌트다. 
    * 개인 정보는 캐시 되지 않도록 표시되어 있어야 하지만, 그 표시를 하지 않는 서버도 있다. 
</br>

* **미 재무성 컴퓨터사고 자문단(The Computer Incident Advisory Capability)에서 1998년에 작성한 쿠키의 위험성이 과대평가됐다는 평가서**
  * 문제 : 쿠키는 웹 서버가 사용자를 식별하려고 사용하는 작은 데이터 조각이다. 쿠키의 개념과 기능에 대해 이해할 수 없는 수준까지 올라온 수많은 뜬소문들은 사용자를 놀라게 하고 그들이 관리자까지도 걱정을 끼칠 수준이다. 
  * 취약성 평가 : 웹브라우저가 쿠키를 사용하여 시스템의 취약한 부분이 손상되거나 스누핑을 하는 것은 근본적으로 있을 수 없다. 
  쿠키는 이전에 당신이 웹 서버에 방문한 적이 있는지 말해주거나, 웹 서버로부터 전달받은 약간의 정보(사용자 번호와 같은)를 다음에 다시 접속하였을 때 서버에게 다시 보내주는 용도일 뿐이다. 
  쿠키 대부분은 당신이 브라우저를 나가기 전까지만 유지되며 브라우저를 나가면 삭제된다. 
  쿠키의 형식 중 하나인 지속 쿠키는 파기 시간을 가지고 있으며 그 파기 시간까지만 당신의 디스크에 저장된다. 
  지속 쿠키는 사용자가 언제 사이트로 돌아오는지 식별해서 사용자의 탐색 습관을 추적하는데 사용될 수 있다. 
  당신이 어디서 왔는지, 당신이 어떤 페이지에 접근했는지는 웹 서버의 로그 파일에도 존재하며, 그것을 통해서 사용자의 브라우징 습관을 추적할 수 있다. 
  쿠키는 그것을 좀 더 편리하게 해줄 뿐이다. 
