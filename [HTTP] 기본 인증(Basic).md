# 인증
여권이나 운전 면허증 같은 신분증을 보여주는 것이나 자동 전화기에 PIN 번호를 입력하는 것 같은 것처럼 당신이 누구인지 증명하는 것.
* **인증 프로토콜과 헤더**
  * HTTP는 필요에 따라 고쳐 쓸 수 있는 제어 헤더를 통해, 다른 인증 프로토콜에 맞추어 확장할 수 있는 프레임워크를 제공
  * HTTP에는 기본 인증, 다이제스트 인증, OAuth 인증이 있다. 
</br>

* 네 가지 인증 단계

|  단계 |  헤더 | 설명 | 메서드/상태 |
|:--------|:--------|:--------|:--------|
| 요청 | | 첫 번째 요청에는 인증 정보가 없다. | GET |
| 인증 요구 | WWW-Authenticate | 서버는 사용자에게 사용자 이름과 비밀번호를 제공하라는 지시의 의미로 401 상태 정보와 함께 요청을 반려한다. 서버에는 각각 다른 비밀번호가 있는 영역들이 있으므로, 서버는 WWW-Authenticate 헤더에 해당 영역을 설명해 놓는다. | 401 Unauthorized |
| 인증 | Authorization | 클라이언트는 요청을 다시 보내는데, 이번에는 인증 알고리즘과 사용자 이름과 비밀번호를 기술한 Authorization 헤더를 함께 보낸다. | GET |
| 성공 | Authentication-info | 인증 정보가 정확하면, 서버는 문서와 함께 응답한다. 어떤 인증 알고리즘은 선택적인 헤더인 Authentication-info에 인증 세션에 관한 추가 정보를 기술해서 응답하기도 한다. | 200 OK |
</br>

* **보안 영역**
  * 웹 서버는 기밀문서를 보안 영역(realm) 그룹으로 나눈다. 
  * 보안 영역은 저마다 다른 사용자 권한을 요구한다.
</br>

# 기본 인증
* 가장 잘 알려진 HTTP인증 규약
* 기본 인증은 원래 HTTP/1.0에 기술되어 있었지만 HTTP인증이 상세 내용을 다루는 [RFC2617](https://www.ietf.org/rfc/rfc2617.txt)로 옮겨졌다.
* 브라우저는 사용자가 입력한 사용자 이름과 비밀번호를 Authorization 요청 헤더 안에 암호화해서 서버로 다시 보낸다. 
* 기본 인증 헤더

|  인증요구/응답 |  헤더 문법과 설명 |
|:--------|:--------|
| 인증요구(서버에서 클라이언트로) | 각 사이트는 보안 영역마다 다른 비밀번호가 있을 것이다. realm은 요청 받은 문서 집합의 이름을 따옴표로 감싼 것으로, 사용자는 이 정보를 보고 어떤 비밀번호를 사용해야 하는지 알 수 있다. </br> **WWW-Authenticate: Basic realm=따옴표로 감싼 문서 집합 정보** |
| 응답(클라이언트에서 서버로) | 사용자 이름과 비밀번호는 콜론으로 잇고, base-64로 인코딩해서 사용자 이름과 비밀번호에 쉽게 국제문자를 포함할 수 있게 하고, 네트워크 트래픽에 사용자 이름과 비밀번호가 노출되지 않게 한다. </br> **Authorization: Basic base-64로 인코딩한 사용자 이름과 비밀번호** |
</br>

* **Base-64 사용자 이름/비밀번호 인코딩**
  * HTTP 기본 인증은 사용자 이름과 비밀번호를 콜론으로 이어서 합치고, Base-64 인코딩 메서드를 사용해 인코딩한다. 
  * Base-64 인코딩은 8비트 바이트로 이루어져 있는 시퀀스를 6비트 덩어리의 시퀀스로 변환한다. 
  * 각 6비트 조각은 대부분 문자와 숫자로 이루어진 특별한 64개의 문자 중에서 선택된다. 
  * Base-64 인코딩은 바이너리, 텍스트, 국제 문자 데이터 문자열 받아서 전송할 수 있게, 그 문자열을 전송 가능한 문자인 알파벳으로 변환하기 위해 발명됐다. 
  * Base-64 인코딩은 국제 문자나 HTTP 헤더에서 사용할 수 없는 문자(큰따옴표, 콜론, 캐리지 리턴)를 포함한 사용자 이름이나 비밀번호를 보내야 할 때 유용하다. 
</br>

* **프락시 인증**
  * 프락시 서버에서 접근 정책을 중앙 관리할 수 있기 때문에 회사 리소스 전체에 대해 통합적인 접근 제어를 하기 위해서 사용하면 좋다. 
  * 웹 서버 인증 vs 프락시 인증

|  웹 서버 |  프락시 서버 |
|:--------|:--------|
| 비인증 상태 코드 : 401 | 비인증 상태 코드 : 407 |
| WWW-Authenticate | Proxy-Authenticate |
| Authorization | Proxy-Authorization |  
| Authenticate-Info | Proxy-Authenticate-Info |
</br>

* **기본 인증의 보안 결함**
  * Base-64로 인코딩한 정보는 디코딩 하면 원본 값을 알 수 있기 때문에 SSL 암호화 채널을 통해 보내거나, 보안이 더 강화된 다이제스트 인증 같은 프로토콜을 사용하는 것이 좋다. 
  * 제삼자가 읽기 힘든 사용자 이름과 비밀번호를 캡처한 다음, 그것을 그대로 원 서버에 보내서 인증에 성공하고 서버에 접근할 수 있다. 기본 인증은 이러한 재전송 공격을 예방하기 위한 어떤 일도 하지 않는다. 
  * 기본 인증이 회사의 인트라넷 접근 제어처럼 보안이 뚫리더라도 치명적이지 않은 애플리케이션에 사용된다 하더라도, 일반 사용자들은 수많은 사이트에 동일한 아이디와 비밀번호를 사용하기 때문에 악용될 수 있다. 
  * 메시지의 인증 헤더를 건드리지는 않지만, 그 외 다른 부분을 수정해서 트랜잭션의 본래 의도를 바꿔버리는 프락시나 중개자가 중간에 개입하는 경우, 기본 인증은 정상적인 동작을 보장하지 않는다. 
  * 기본 인증은 가짜 서버의 위장에 취약하다. 만약 사용자가 가짜 서버나 가짜 게이트에 연결되어 있는데도, 기본 인증을 수행하는 서버에 연결되어 있다고 믿고 있다면, 공격자는 사용자에게 비밀번호를 요청하고 그것을 나중에 사용할 목적으로 저장한 다음 에러가 난 척을 할 것이다. 
  
  
