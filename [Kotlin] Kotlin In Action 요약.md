# 함수 정의와 호출
  * 코틀린은 자체 컬렉션 클래스를 정의하지 않지만 Java 클래스를 확장해서 더 풍부한 API를 제공한다.
  <br>
  
  * 함수 파라미터의 디폴트 값을 정의하면 오버로딩한 함수를 정의할 필요성이 줄어든다. 이름붙인 인자를 사용하면 함수의 인자가 많을 때 함수 호출의 가독성을 더 향상시킬 수 있다.
  <br>
  
  * 코틀린 파일에서 클래스 멤버가 아닌 최상위 함수와 프로퍼티를 직접 선언할 수 있다. 이를 활용하면 코드 구조를 더 유연하게 만들 수 있다.
  <br>
  
  * 확장 함수와 프로퍼티를 사용하면 외부 라이브러리에 정의된 클래스를 포함해 모든 클래스의 API를 그 클래스의 소스코드를 바꿀 필요 없이 확장할 수 있다. 확장 함수를 사용해도 실행 시점에 부가 비용이 들지 않는다.
  <br>
  
  * 중위(```infix```) 호출을 통해 인자가 하나 밖에 없는 메소드나 확장 함수를 더 깔끔한 구문으로 호출할 수 있다.
  <br>
  
  * 코틀린은 정규식과 일반 문자열을 처리할 때 유용한 다양한 문자열 처리 함수를 제공한다.
  <br>
  
  * 자바 문자열로 표현하려면 수많은 이스케이프가 필요한 문자열의 경우 3중 따옴표 문자열을 사용하면 더 깔끔하게 표현할 수 있다.
  <br>
  <br>

# 클래스, 객체, 인터페이스
  * 코틀린의 인터페이스는 자바 인터페이스와 비슷하지만 디폴트 구현을 포함할 수 있고(Java 8부터는 Java에서도 가능), 프로퍼티도 포함할 수 있다(Java에서는 불가능).
  <br>
  
  * 모든 코틀린 선언은 기본적으로 ```final```이며 ```public```이다.
  <br>

  * 선언이 ```final```이 되지 않게 만들려면(상속과 오버라이딩이 가능하게 하려면) 앞에 ```open```을 붙여야 한다.
  <br>
  
  * ```internal``` 선언은 같은 모듈 안에서만 볼 수 있다.
  <br>
  
  * 중첩(Nested) 클래스는 기본적으로 내부(Inner) 클래스가 아니다. 바깥쪽(Outer) 클래스에 대한 참조를 중첩 클래스에 포함시키려면 ```inner``` 키워드를 중첩 클래스 선언 앞에 붙여서 내부 클래스로 만들어야 한다.
  <br>
  
  * ```sealed``` 클래스를 상속하는 클래스를 정의하려면 반드시 부모 클래스 정의 안에 중첩(또는 내부) 클래스로 정의해야 한다. (코틀린 1.1부터는 같은 파일 안에만 있으면 된다).
  <br>
  
  * 초기화 블록과 부 생성자를 활용해 클래스 인스턴스를 더 유연하게 초기화할 수 있다.
  <br>
  
  * ```field``` 식별자를 통해 프로퍼티 접근자(게터와 세터)안에서 프로퍼티의 데이터를 저장하는 데 쓰이는 뒷받침하는 필드를 참조할 수 있다.
  <br>
  
  * 데이터 클래스를 사용하면 컴파일러가 ```equals```, ```hashCode```, ```toString```, ```copy``` 등의 메소드를 자동으로 생성해준다.
  <br>
  
  * 클래스 위임을 사용하면 위임 패턴을 구현할 때 필요한 수많은 성가진 준비 코드를 줄일 수 있다.
  <br>
  
  * 객체 선언을 사용하면 코틀린답게 싱글턴 클래스를 정의할 수 있다.
  <br>
  
  * (패키지 수준 함수와 프로퍼티 및 동반 객체와 더불어)동반 객체는 Java의 정적 메소드와 필드 정의를 대신한다.
  <br>
  
  * 동반 객체(```companion object```)도 다른 (싱글턴) 객체와 마찬가지로 인터페이스를 구현할 수 있다. 외부에서 동반 객체에 대한 확장 함수와 프로퍼티를 정의할 수 있다.
  <br>
  
  * 코틀린의 객체 식은 Java의 무명 내부 클래스를 대신한다. 하지만 코틀린 객체 식은 여러 인스턴스를 구현하거나 객체가 포함된 영역(scope)에 있는 변수의 값을 변경할 수 있는 등 Java 무명 내부 클래스보다 더 많은 기능을 제공한다.
  <br>
  <br>
  
# 람다로 프로그래밍
 * 람다를 사용하면 코드 조각을 다른 함수에게 인자로 넘길 수 있다.
 <br>
 
 * 코틀린에서는 람다가 함수 인자인 경우 괄호 밖으로 람다를 빼낼 수 있고, 람다의 인자가 단 하나뿐인 경우 인자 이름을 지정하지 않고 ```it```이라는 디폴트 이름으로 부를 수 있다. 
 <br>
 
 * 람다 안에 있는 코드는 그 람다가 들어있는 바깥 함수의 변수를 읽거나 쓸 수 있다.
 <br>
 
 * 메소드, 생성자, 프로퍼티의 이름 앞에 ```::```을 붙이면 각각에 대한 참조를 만들 수 있다. 그런 참조를 람다 대신 다른 함수에게 넘길 수 있다.
 <br>
 
 * ```filter```, ```map```, ```all```, ```any``` 등의 함수를 활용하면 컬렉션에 대한 대부분의 연산을 직접 원소를 이터레이션하지 않고 수행할 수 있다.
 <br>
 
 * 시퀀스를 사용하면 중간 결과를 담는 컬렋녀을 생성하지 않고도 컬렉션에 대한 여러 연산을 조합할 수 있다.
 <br>
 
 * 함수형 인터페이스(추상 메소드가 단 하나뿐인 ```SAM``` 인터페이스)를 인자로 받는 Java 함수를 호출할 경우 람다를 함수형 인터페이스 인자 대신 넘길 수 있다.
 <br>
 
 * 수신 객체 지정 람다를 사용하면 람다 안에서 미리 정해둔 수신 객체의 메소드를 직접 호출할 수 있다.
 <br>
 
 * 표준 라이브러리의 ```with``` 함수를 사용하면 어떤 객체에 대한 참조를 반복해서 언급하지 않으면서 그 객체의 메소드를 호출할 수 있다. ```apply```를 사용하면 어떤 객체라도 빌더 스타일의 API를 사용해 생성하고 초기화할 수 있다.
 <br>
 <br>
 
# 코틀린 타입 시스템
 * 코틀린은 널이 될 수 있는 타입을 지원해 ```NullPointerException``` 오류를 컴파일 시점에 감지할 수 있다.
 <br>
 
 * 코틀린의 안전한 호출(```?.```), 엘비스 연산자(```?:```), 널 아님 단언(```!!```), ```let``` 함수 등을 사용하면 널이 될 수 있는 타입을 간결한 코드로 다룰 수 있다.
 <br>
 
 * as?연산자를 사용하면 값을 다른 타입으로 변환하는 것과 변환이 불가능한 경우를 처리하는 것을 한꺼번에 편리하게 처리할 수 있다.
 <br>
 
 * Java에서 가져온 타입은 코틀린에서 플랫폼 타입으로 취급된다. 개발자는 플랫폼 타입을 널이 될 수 있는 타입으로도, 널이 될 수 없는 타입으로도 사용할 수 있다. 
 <br>
 
 * 코틀린에서는 수를 표현하는 타입(```Int``` 등)이 일반 클래스와 똑같이 생겼고 일반 클래스와 똑같이 동작한다. 하지만 대부분 컴파일러는 숫자 타입을 Java 원시 타입(```int``` 등)으로 컴파일한다.
 <br>
 
 * ```Any``` 타입은 다른 모든 타입의 조상 타입이며, Java의 ```Object```에 해당한다. ```Unit```은 Java의 ```void```와 비슷하다.
 <br>
 
 * 정상적으로 끝나지 않은 함수의 반환 타입을 지정할 때 ```Nothing``` 타입을 사용한다.
 <br>
 
 * 코틀린 컬렉션은 표준 Java 컬렉션 클래스를 사용한다. 하지만 코틀린은 Java보다 컬렉션을 더 개선해서 읽기 전용 컬렉션과 변경 가능한 컬렉션을 구별해 제공한다.
 <br>
 
 * Java 클래스를 코틀린에서 확장하거나 Java 인터페이스를 코틀린에서 구현하는 경우 메소드 파라미터의 널 가능성과 변경 가능성에 대해 깊이 생각해야 한다. 
 <br>
 
 * 코틀린의 ```Array``` 클래스는 일반 제네릭 클래스처럼 보인다. 하지만 ```Array```는 Java 배열로 컴파일된다.
 <br>
 
 * 원시 타입의 배열은 ```IntArray```와 같이 각 타입에 대한 특별한 배열로 표현된다.
 <br>
 <br>

# 연산자 오버로딩과 기타 관례
 * 코틀린에서는 정해진 이름의 함수를 오버로딩함으로써 표준 수학 연산자를 오버로딩할 수 있다. 하지만 직접 새로운 연산자를 만들 수는 없다.
 <br>
 
 * 비교 연산자는 ```equals```와 ```compareTo``` 메소드로 변환된다.
 <br>
 
 * 클래스에 ```get```, ```set```, ```contains```라는 함수를 정의하면 그 클래스의 인스턴스에 대해 ```[]```와 ```in``` 연산을 사용할 수 있고, 그 객체를 코틀린 컬렉션 객체와 비슷하게 다룰 수 있다.
 <br>
 
 * 미리 정해진 관례를 따라 ```rangeTo```, ```iterator``` 함수를 정의하면 범위를 만들거나 컬렉션과 배열의 원소를 이터레이션할 수 있다.
 <br>
 
 * 구조 분해 선언을 통해 한 객체의 상태를 분해해서 여러 변수에 대입할 수 있다. 함수가 여러 값을 한꺼번에 반환해야 하는 경우 구조 분해가 유용하다. 데이터 클래스에 대한 구조 분해는 거저 사용할 수 있지만, 커스텀 클래스의 인스턴스에서 구조 분해를 사용하려면 ```componentN``` 함수를 정의해야 한다.
 <br>
 
 * 위임 프로퍼티를 통해 프로퍼티 값을 저장하거나 초기화하거나 읽거나 변경할 때 사용하는 로직을 재활용할 수 있다. 위임 프로퍼티는 프레임워크를 만들 때 아주 유용하다.
 <br>
 
 * 표준 라이브러리 함수인 ```lazy```를 통해 지연 초기화 프로퍼티를 쉽게 구현할 수 있다. 
 <br>
 
 * Delegates.observable 함수를 사용하면 프로퍼티 변경을 관찰할 수 있는 관찰자를 쉽게 추가할 수 있다.
 <br>
 
 * 맵을 위임 객체로 사용하는 위임 프로퍼티를 통해 다양한 속성을 제공하는 객체를 유연하게 다룰 수 있다.
 <br>
 <br>
 
# 고차 함수: 파라미터와 반환 값으로 람다 사용
 * 함수 타입을 사용해 함수에 대한 참조를 담는 변수나 파라미터나 반환 값을 만들 수 있다.
 <br>
 
 * 고차 함수는 다른 함수를 인자로 받거나 함수를 반환한다. 함수의 파라미터 타입이나 반환 타입으로 함수 타입을 사용하면 고차 함수를 선언할 수 있다.
 <br>
 
 * 인라인 함수를 컴파일할 때 컴파일러는 그 함수의 본문과 그 함수에게 전달된 람다의 본문을 컴파일한 바이트코드를 모든 함수 호출 지점에 삽입해준다. 이렇게 만들어지는 바이트코드는 람다를 활용한 인라인 함수 코드를 풀어서 직접 쓴 경우와 비교할 때 아무 부가 비용이 들지 않는다.
 <br>
 
 * 고차 함수를 사용하면 컴포넌트를 이루는 각 부분의 코드를 더 잘 재사용할 수 있다. 또 고차 함수를 활용해 강력한 제네릭 라이브러리를 만들 수 있다.
 <br>
 
 * 인라인 함수에서는 람다 안에 있는 ```return```문이 바깥쪽 함수를 반환시키는 넌 로컬 ```return```을 사용할 수 있다. 
 <br>
 
 * 무명 함수는 람다 식을 대신할 수 있으며 ```return``` 식을 처리하는 규칙이 일반 람다 식과는 다르다. 본문 여러곳에서 ```return```해야 하는 코드 블록을 만들어야 한다면 람다 대신 무명 함수를 쓸 수 있다.
 <br>
 <br>
 
# 제네릭스
 * 코틀린 제네릭스는 Java와 아주 비슷하다. 제네릭 함수와 클래스를 Java와 비슷하게 선언할 수 있다.
 <br>
 
 * Java와 마찬가지로 제네릭 타입의 타입 인자는 컴파일 시점에만 존재한다.
 <br>
 
 * 타입 인자가 실행 시점에 지워지므로 타입 인자가 있는 타입(제네릭 타입)을 ```is``` 연산자를 사용해 검사할 수 없다. 
 <br>
 
 * 인라인 함수의 타입 매개변수를 ```reified```로 표시해서 실체화하면 실행 시점에 그 타입을 ```is```로 검사하거나 ```java.lang.Class``` 인스턴스를 얻을 수 있다.
 <br>
 
 * 변성은 기저 클래스가 같고 타입 파라미터가 다른 두 제네릭 타입 사이의 상위/하위 타입 관계가 타입 인자 사이의 상위/하위 타입 관계에 의해 어떤 영향을 받는지를 명시하는 방법이다.
 <br>
 
 * 제네릭 클래스의 타입 파라미터가 아웃 위치에서만 사용되는 경우(생산자) 그 타입 파라미터를 ```out```으로 표시해서 공변적으로 만들 수 있다.
 <br>
 
 * 공변적인 경우와 반대로 제네릭 클래스의 타입 파라미터가 인 위치에서만 사용되는 경우(소비자) 그 타입 파라미터를 ```in```으로 표시해서 반공변적으로 만들 수 있다.
 <br>
 
 * ```out```은 Producer, ```in```은 Consumer
 <br>
 
 * 코틀린의 읽기 전용 ```List``` 인터페이스는 공변적이다. 따라서 ```List<String>```은 ```List<Any>```의 하위 타입이다.
 <br>
 
 * 함수 인터페이스는 첫 번째 타입 파라미터에 대해서는 반공변적이고, 두 번째 타입 파라미터에 대해서는 공변적이다(다른 말로 하면 함수 타입은 함수 파라미터 타입에 대해서는 반공변적이며 함수 반환 타입에 대해서는 공변적이다). 그래서 ```(Animal) -> Int```는 ```(Cat) -> Number```의 하위 타입이다.
 <br>
 
 * 코틀린에서는 제네릭 클래스의 공변성을 전체적으로 지정하거나(선언 지점 변성), 구체적인 사용 위치에서 지정할 수 있다(사용 지점 변성).
 <br>
 
 * 제네릭 클래스의 타입 인자가 어떤 타입인지 정보가 없거나 타입 인자가 어떤 타입인지가 중요하지 않을 때 스타 프로젝션 구문을 사용할 수 있다.
 <br>
 <br>

# 애노테이션과 리플렉션
 * 코틀린에서 애노테이션을 적용할 때 사용하는 문법은 Java와 거의 같다.
 <br>
 
 * 코틀린에서는 Java보다 더 넓은 대상에 애노테이션을 적용할 수 있다. 그런 대상으로는 파일과 식을 들 수 있다.
 <br>
 
 * 애노테이션 인자로 원시 타입 값, 문자열, Enum, 클래스 참조, 다른 애노테이션 클래스의 인스턴스, 그리고 지금까지 말한 여러 유형의 값으로 이뤄진 배열을 사용할 수 있다.
 <br>
 
 * ```@get:Rule```을 사용해 애노테이션의 사용 대상을 명시하면 한 코틀린 선언이 여러 가지 바이트코드 요소를 만들어내는 경우 정확히 어떤 부분에 애노테이션을 적용할지 지정할 수 있다. 
 <br>
 
 * 애노테이션 클래스를 정의할 때는 본문이 없고 주 생성자의 모든 파라미터를 ```val``` 프로퍼티로 표시한 코틀린 클래스를 사용한다.
 <br>
 
 * 메타애노테이션을 사용해 대상, 애노테이션 유지 방식 등 여러 애노테이션 특성을 지정할 수 있다.
 <br>
 
 * 리플렉션 API를 통해 실행 시점에 객체의 메소드와 프로퍼티를 열거하고 접근할 수 있다. 리플렉션 API에는 클래스(```KClass```), 함수(```KFunction```) 등 여러 종류의 선언을 표현하는 인터페이스가 들어있다.
 <br>
 
 * 클래스를 컴파일 시점에 알고 있다면 ```KClass``` 인스턴스를 얻기 위해 ```ClassName:class```를 사용한다. 하지만 실행 시점에 ```obj``` 변수에 담긴 객체로부터 ```KClass``` 인스턴스를 얻기 위해서는 ```obj.javaClass.kotlin```을 사용한다.
 <br>
 
 * ```KFunction```과 ```KProperty``` 인터페이스는 모두 ```KCallable```을 확장한다. ```KCallable```은 제네릭 ```call``` 메소드를 제공한다.
 <br>
 
 * ```KCallable.callBy``` 메소드를 사용하면 메소드를 호출하면서 디폴트 파라미터 값을 사용할 수 있다.
 <br>
 
 * ```KFunction0```, ```KFunction1``` 등의 인터페이스는 모두 파라미터 수가 다른 함수를 표현하며, ```invoke``` 메소드를 사용해 함수를 호출할 수 있다.
 <br>
 
 * ```KProperty0```는 최상위 프로퍼티나 변수, ```KProperty1```은 수신 객체가 있는 프로퍼티에 접근할 때 쓰는 인터페이스다. 두 인터페이스 모두 ```get``` 메소드를 사용해 프로퍼티 값을 가져올 수 있다. ```KMutableProperty0```과 ```KMutableProperty1```은 각각 ```KProperty0```과 ```KProperty1```을 확장하며, ```set``` 메소드를 통해 프로퍼티값을 변경할 수 있게 해준다.
 <br>
 <br>
 
# DSL 만들기
 * 내부 ```DSL```은 여러 메소드 호출로 구성된 구조를 더 쉽게 표현할 수 있게 해주는 API를 설계할 때 사용할 수 있는 패턴이다.
 <br>
 
 * 수신 객체 지정 람다는 람다 본문 안에서 메소드를 결정하는 방식을 재정의함으로써 여러 요소를 중첩시킬 수 있는 구조를 만들 수 있다.
 <br>
 
 * 수신 객체 지정 람다를 파라미터로 받은 경우 그 람다의 타입은 확장 함수 타입이다. 람다를 파라미터로 받아서 사용하는 함수는 람다를 호출하면서 람다에 수신 객체를 제공한다.
 <br>
 
 * 외부 템플릿이나 마크업 언어 대신 코틀린 내부 ```DSL```을 사용하면 코드를 추상화하고 재활용할 수 있다.
 <br>
 
 * 중위 호출 인자로 특별히 이름을 붙인 객체를 사용하면 특수 기호를 사용하지 않는 실제 영어처럼 보이는 ```DSL```을 만들 수 있다.
 <br>
 
 * 원시 타입에 대한 확장을 정의하면 날짜 등의 여러 종류의 상수를 더 읽기 좋게 만들 수 있다.
 <br>
 
 * ```invoke``` 관례를 사용하면 객체를 함수처럼 다룰 수 있다.
 <br>
 
 * ```kotlinx.html``` 라이브러리는 ```HTML``` 페이지를 생성하기 위한 내부 ```DSL```을 제공한다. 그 내부 ```DSL```을 확장하면 여러 프론트엔드 개발 프레임워크를 지원하게 만들 수 있다.
 <br>
 
 * 코틀린테스트 라이브러리는 단위 테스트에서 읽기 쉬운 단언문을 지원하는 내부 DSL을 제공한다.
 <br>
 
 * ```Exposed``` 라이브러리는 데이터베이스를 다루기 위한 내부 DSL을 제공한다.
 <br>
 
 * ```Anko``` 라이브러리는 안드로이드 개발에 필요한 여러 도구를 제공한다. 그런 도구중에는 UI 레이아웃을 정의하기 위한 내부 ```DSL```도 있다.
